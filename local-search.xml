<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>分布式一致性协议之Raft</title>
    <link href="/2022/03/09/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E4%B9%8BRaft/"/>
    <url>/2022/03/09/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E4%B9%8BRaft/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raft.github.io/logo/solo.svg"></p><p>最近看<code>RocketMQ</code>的时候，了解到v4.5.0之后，broker采用遵循raft协议的复制组来实现数据一致性。虎躯一震，raft协议在现在的脑子里变的熟悉又陌生…</p><p>问题不大，重新刷一遍raft。</p><p>先贴官网：<a href="https://raft.github.io/">The Raft Consensus Algorithm</a></p><p>再贴动画演示：<a href="http://thesecretlivesofdata.com/raft">Raft: Understandable Distributed Consensus</a></p><p>ps：里边的动图挺有意思😈</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ps:来自维基百科</p><blockquote><p><strong>Raft</strong>是一种用于替代<a href="https://zh.wikipedia.org/wiki/Paxos">Paxos</a>的<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E8%AD%98%E6%A9%9F%E5%88%B6">共识</a>算法。相比于<a href="https://zh.wikipedia.org/wiki/Paxos">Paxos</a>，Raft的目标是提供更清晰的逻辑分工使得算法本身能被更好地理解，同时它安全性更高，并能提供一些额外的特性。[<a href="https://zh.wikipedia.org/wiki/Raft#cite_note-raft-1">1]</a>[<a href="https://zh.wikipedia.org/wiki/Raft#cite_note-raft-paper-2">2]</a>:1Raft能为在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4">计算机集群</a>之间部署<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">有限状态机</a>提供一种通用方法，并确保集群内的任意节点在某种状态转换上保持一致。Raft算法的开源实现众多，在<a href="https://zh.wikipedia.org/wiki/Go">Go</a>、<a href="https://zh.wikipedia.org/wiki/C%2B%2B">C++</a>、<a href="https://zh.wikipedia.org/wiki/Java">Java</a>以及 <a href="https://zh.wikipedia.org/wiki/Scala">Scala</a>中都有完整的代码实现。Raft这一名字来源于”Reliable, Replicated, Redundant, And Fault-Tolerant”（“可靠、可复制、可冗余、可容错”）的首字母缩写。[<a href="https://zh.wikipedia.org/wiki/Raft#cite_note-3">3]</a></p><p>集群内的节点都对选举出的领袖采取信任，因此Raft不是一种<a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">拜占庭容错</a>算法。[<a href="https://zh.wikipedia.org/wiki/Raft#cite_note-raft-paper-2">2]</a></p></blockquote><p>Raft使用<strong>选举领袖</strong>的方式做共识算法。一个典型的Raft cluster一般有5台服务器，这可以应对两次故障。</p><p>在一个Raft cluster里，服务器有三种身份：</p><ol><li>领袖（leader）</li><li>跟随者（follower）</li><li>候选人（candidate）</li></ol><p><code>leader</code>在同一时间只会有一个，但不是一成不变的。剩下的服务器都是<code>follower</code>。</p><p><code>leader</code>会处理所有的外部请求，如果一个服务器不是<code>leader</code>，那么这个请求会被转发到<code>leader</code>处理。</p><p><code>leader</code>会在一个固定的时间段里给<code>follower</code>发送心跳（heartbeat），告诉<code>follower</code>：<em><strong>hi boys ! I am alive !</strong></em> 💋 </p><p>每个<code>follower</code>都有自己的超时窗口（每个follower的timeout可能不一样），当超过一定时间没有收到<code>leader</code>的heartbeat之后，集群就会进入选举状态。🙋</p><p>从下边三个方面来了解<code>raft</code></p><ul><li>领袖选举（Leader Election）</li><li>记录复写（Log Replication）</li><li>安全性（Safety）</li></ul><h2 id="领袖选举（leader-election）"><a href="#领袖选举（leader-election）" class="headerlink" title="领袖选举（leader election）"></a>领袖选举（leader election）</h2><img src="https://s3.bmp.ovh/imgs/2022/03/4f18033de732207c.png" alt="image-20220309153949284" style="zoom:80%;" /><p>上图可以看出，所有的节点期初都是follower角色，如果在一段时间内没有收到leader的心跳（times out），那么便切换到candidate角色，然后发起选举（starts election）；如果收到大多数的投票，那么切换成leader角色；</p><p>有两个<code>超时时间</code>（timeout）会影响leader election:</p><h3 id="election-timeout"><a href="#election-timeout" class="headerlink" title="election timeout"></a><strong>election timeout</strong></h3><p>follower等待成为candidate的时间，这个时间在150ms~300ms的范围内是随机的。</p><p>如果超过了这个timeout时间还没有收到leader的心跳，那么这个follower会做下边两件事：</p><ol><li>切换成candidate的角色</li><li>它的Term : 0-&gt;1 and  Vote Count : 0 -&gt;1 </li></ol><p>然后，它会向其它所有节点（nodes）发送一个<em>投票请求</em>（<code>Request Vote</code>）。如果接受这个请求的节点在此任期（Term）内还没有投过票，那么就会投这个Request Vote的发起方，<u>并且将自己的election timeout重置</u>。</p><img src="https://s3.bmp.ovh/imgs/2022/03/dd72e822d6c9dfc3.png" alt="image-20220309161641140" style="zoom: 50%;" /><p>当一个candidate节点有大多数的投票的时候，那么和这个节点切换为<code>leader</code>节点。</p><h3 id="heartbeat-timeout"><a href="#heartbeat-timeout" class="headerlink" title="heartbeat timeout"></a>heartbeat timeout</h3><p>leader节点开始发送<code>Append Entries</code>信息到所有的follower节点，这些信息按照<strong>heartbeat timeout</strong>指定的时间间隔去发送。followers收到Append Entries请求后<u>会重置自己的election timeout并且做出响应</u>。</p><img src="https://s3.bmp.ovh/imgs/2022/03/ebe0ba4e35560cd4.png" alt="image-20220309164255003" style="zoom:50%;" /><p>至此，这个任期（Term）将会一直存在，直到某一个follower收不到leader的心跳并且切换成了candidate角色。</p><h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><ol><li>在一个偶数的raft cluster中一旦leader不可用，剩下的几个candidate在同一时间可能有“脑裂”（split vote）的风险。当然这种case发生的概率还是极低的，只有在leader不可用时，剩下的candidate中有两个节点的剩余election time完全一致时才会发生。所以官方建议一个raft cluster最少要有五个节点。</li><li>为了避免<code>split vote</code>，raft引入了<code>randomized election timeouts</code>避免平票的case发生。</li><li>raft是一个<code>leader-based</code>共识算法，节点的数据尽量是奇数个，这样可以尽量保证<code>majority</code>的出现。</li></ol><h2 id="记录复写（log-replication）"><a href="#记录复写（log-replication）" class="headerlink" title="记录复写（log replication）"></a>记录复写（log replication）</h2><p>当集群中的leader被选举出来之后，客户端的所有请求都会发送到leader，leader来调度这些请求的顺序，并且要保证leader与followers状态的一致性。</p><h3 id="Replicated-state-machines"><a href="#Replicated-state-machines" class="headerlink" title="Replicated state machines"></a>Replicated state machines</h3><p>共识算法一般是基于复制状态机（Replicated state machines）实现的。</p><p>ps：<em>不展开了，有时间再专门写一篇</em>🏃‍♀️🏃‍♂️</p><p>raft中，<code>leader</code>将客户端请求(command)封装成一个个<code>log entry</code>，然后将这些<code>log entries</code>复制（replicate）到所有的<code>follower</code>节点，然后所有节点按照顺序应用<code>log entry</code>中的<code>command</code>，那么大家最终的状态就是一致的了。</p><img src="https://s3.bmp.ovh/imgs/2022/03/fb6457b7c11d6578.png" alt="image-20220309215626133" style="zoom: 80%;" /><h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h3><ol><li>client发了一个请求给到leader，leader将“变化”（change）添加（appended）到自己的log中。</li><li>leader在下一次heartbeat时，将“变化”（change）发送到所有的followers</li><li>一旦大多数follower承认了这个条目（entry），那么这个条目就会被提交（committed）<ol><li>类似2PC，区别是leader不需要全部节点的回复，这样只要超过一半节点处于工作状态则系统就是可用的</li></ol></li><li>leader将请求response发送到client</li></ol><h3 id="NOTE-1"><a href="#NOTE-1" class="headerlink" title="NOTE"></a>NOTE</h3><ul><li>Raft可以在网络分区（network partitions）时保持一致</li><li>raft算法为了保证高可用，并不是强一致的，而是最终一致的</li></ul><h2 id="安全性（safety）"><a href="#安全性（safety）" class="headerlink" title="安全性（safety）"></a>安全性（safety）</h2><p>没时间了，下次再说…🏃‍♂️</p>]]></content>
    
    
    <categories>
      
      <category>分布式一致性协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raft</tag>
      
      <tag>分布式</tag>
      
      <tag>一致性协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git-rebase入门教程</title>
    <link href="/2022/03/08/git-rebase%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2022/03/08/git-rebase%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<img src="https://www.runoob.com/wp-content/uploads/2015/02/git-command.jpg" style="zoom: 150%;" /><h2 id="rebase基础介绍"><a href="#rebase基础介绍" class="headerlink" title="rebase基础介绍"></a>rebase基础介绍</h2><p>git代码合并有两种，git merge 和 git rebase 。两者目的相同，都是把不同分支的提交合并到一起，但是过程有差异。</p><p><strong>git merge</strong></p><p>作用：把源分支的提交合并到目标分支。过程中，目标分支改变，源分支不变。</p><p>优点：简单易上手/保留了提交历史和时间次序/分支结构不变</p><p>缺点：提交历史被大量的merge操作污染/<a href="http://www.ruanyifeng.com/blog/2018/12/git-bisect.html">git bisect</a>调试困难</p><p><strong>git rebase</strong></p><p>作用：清除了历史，将一个分支完全转移到了目标分支</p><p>优点：复杂的历史变成优雅的提交线</p><p>缺点：分支上下文模糊了/dev分支以及feature分支需要经常更新release分支变动到本地</p><img src="/2022/03/08/git-rebase%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/rebse-merge.png" class="" title="图片引用方法一"><h2 id="使用rebase时，正确的git-flow是怎样的"><a href="#使用rebase时，正确的git-flow是怎样的" class="headerlink" title="使用rebase时，正确的git flow是怎样的"></a>使用rebase时，正确的git flow是怎样的</h2><ul><li>每个feature分支都有单独的分支负责人，分支负责人需要在feature分支开发过程中每天rebase  release分支，同时告诉feature分支的自开发分支，及时跟进更新。</li><li>feature子分支开发人员需要在开发完自己的任务之后，将自己分支的点合并成一个点，然后合并到feature分支。</li><li>feature分支负责人在确定所有子分支都已开发完毕并且都压点后合并到feature分支后，交付测试验收。</li><li>测试验收通过后将feature到release分支等待上线。</li></ul><h3 id="1-feature负责人拉出功能分支，并告知功能开发人员相关分支已拉出，可以创建自己的开发分支。"><a href="#1-feature负责人拉出功能分支，并告知功能开发人员相关分支已拉出，可以创建自己的开发分支。" class="headerlink" title="1.feature负责人拉出功能分支，并告知功能开发人员相关分支已拉出，可以创建自己的开发分支。"></a>1.<strong>feature负责人拉出功能分支，并告知功能开发人员相关分支已拉出，可以创建自己的开发分支。</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git checkout -b feature-xxx</span><br><span class="hljs-meta">$ </span><span class="language-bash">git push --set-upstream origin feature-xxx</span><br></code></pre></td></tr></table></figure><h3 id="2-feature开发人员拉出属于自己的业务开发分支"><a href="#2-feature开发人员拉出属于自己的业务开发分支" class="headerlink" title="2.feature开发人员拉出属于自己的业务开发分支"></a>2.<strong>feature开发人员拉出属于自己的业务开发分支</strong></h3><p>张三</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git checkout -b feature-xxx-zhangsan</span><br><span class="hljs-meta">$ </span><span class="language-bash">git push --set-upstream origin feature-xxx-zhangsan</span><br></code></pre></td></tr></table></figure><p>李四</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git checkout -b feature-xxx-lisi</span><br><span class="hljs-meta">$ </span><span class="language-bash">git push --set-upstream origin feature-xxx-lisi</span><br></code></pre></td></tr></table></figure><h3 id="3-feature开发人员开始做业务开发"><a href="#3-feature开发人员开始做业务开发" class="headerlink" title="3.feature开发人员开始做业务开发"></a>3.<strong>feature开发人员开始做业务开发</strong></h3><p>张三</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&#x27;张三提交1&#x27;</span></span><br><span class="hljs-meta">$ </span><span class="language-bash">git push</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&#x27;张三提交2&#x27;</span></span><br><span class="hljs-meta">$ </span><span class="language-bash">git push</span><br></code></pre></td></tr></table></figure><p>李四</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&#x27;李四提交1&#x27;</span></span><br><span class="hljs-meta">$ </span><span class="language-bash">git push</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&#x27;李四提交2&#x27;</span></span><br><span class="hljs-meta">$ </span><span class="language-bash">git push</span><br></code></pre></td></tr></table></figure><img src="/2022/03/08/git-rebase%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210808225537689.png" class="" title="图片引用方法一"><h3 id="4-fearure开发人员完成自己的开发任务之后将自己的提交记录合并成一个点"><a href="#4-fearure开发人员完成自己的开发任务之后将自己的提交记录合并成一个点" class="headerlink" title="4.fearure开发人员完成自己的开发任务之后将自己的提交记录合并成一个点"></a>4.fearure开发人员完成自己的开发任务之后将自己的提交记录合并成一个点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git rebase -i 292141c  5b43fa0</span><br>-------------------------<br>pick 6e48844 张三提交1<br>pick 5f8e351 张三提交2     //进入编辑模式将第二行开始的pick全部修改成s，然后esc :wq保存，进入commit msg界面做整理<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">Rebase 356a5c0..5f8e351 onto 356a5c0 (2 commands)</span><br><span class="hljs-meta">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Commands:</span></span><br><span class="hljs-meta"># </span><span class="language-bash">p, pick &lt;commit&gt; = use commit</span><br><span class="hljs-meta"># </span><span class="language-bash">r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="hljs-meta"># </span><span class="language-bash">e, edit &lt;commit&gt; = use commit, but stop <span class="hljs-keyword">for</span> amending</span><br><span class="hljs-meta"># </span><span class="language-bash">s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="hljs-meta"># </span><span class="language-bash">f, fixup &lt;commit&gt; = like <span class="hljs-string">&quot;squash&quot;</span>, but discard this commit<span class="hljs-string">&#x27;s log message</span></span><br><span class="hljs-meta"># </span><span class="language-bash"><span class="hljs-string">x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="hljs-meta"># </span><span class="language-bash"><span class="hljs-string">b, break = stop here (continue rebase later with &#x27;</span>git rebase --<span class="hljs-built_in">continue</span><span class="hljs-string">&#x27;)</span></span><br><span class="hljs-meta"># </span><span class="language-bash"><span class="hljs-string">d, drop &lt;commit&gt; = remove commit</span></span><br><span class="hljs-meta"># </span><span class="language-bash"><span class="hljs-string">l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="hljs-meta"># </span><span class="language-bash"><span class="hljs-string">t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="hljs-meta"># </span><span class="language-bash"><span class="hljs-string">m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="hljs-meta"># </span><span class="language-bash"><span class="hljs-string">.       create a merge commit using the original merge commit&#x27;</span>s</span><br><span class="hljs-meta"># </span><span class="language-bash">.       message (or the oneline, <span class="hljs-keyword">if</span> no original merge commit was</span><br><span class="hljs-meta"># </span><span class="language-bash">.       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br><span class="hljs-meta">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="hljs-meta">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="hljs-meta">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="hljs-meta">#</span><span class="language-bash"></span><br><span class="language-bash"></span><br><br></code></pre></td></tr></table></figure><img src="/2022/03/08/git-rebase%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/git-rebase.gif" class="" title="图片引用方法一"><img src="/2022/03/08/git-rebase%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210808233344850.png" class="" title="图片引用方法一"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git status</span><br>On branch feature-xxx-zhangsan<br>Your branch and &#x27;origin/feature-xxx-zhangsan&#x27; have diverged,<br>and have 1 and 2 different commits each, respectively.<br>  (use &quot;git pull&quot; to merge the remote branch into yours)<br><br>nothing to commit, working tree clean<br><br></code></pre></td></tr></table></figure><p>idea git 中可以看到feature-xxx-zhangsan的本地分支已经将两次提交合并成<strong>一个点</strong></p><blockquote><p>have 1 and 2 different commits each, respectively.</p></blockquote><p>此时需要将本地分支<strong>强推</strong>到远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git push -f</span> <br></code></pre></td></tr></table></figure><img src="/2022/03/08/git-rebase%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210808233945968.png" class="" title="图片引用方法一"><h3 id="5-合并到feature分支"><a href="#5-合并到feature分支" class="headerlink" title="5.合并到feature分支"></a>5.合并到feature分支</h3><p>先保证本地的feature分支是最新的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git checkout feature-xxx</span><br><span class="hljs-meta">$ </span><span class="language-bash">git pull</span><br><span class="hljs-meta">$ </span><span class="language-bash">git status</span><br></code></pre></td></tr></table></figure><p>合并分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git rebase feature-xxx-zhangsan feature-xxx</span><br>Successfully rebased and updated refs/heads/feature-xxx.<br><br>注意此时的本地分支已经切换到feature-xxx，也就是rebase命令的第二个参数<br>gir rebase branchA branchB其实会做两件事情<br>1.git checkout branchB<br>2.git rebase branchA<br><span class="hljs-meta">$ </span><span class="language-bash">git branch</span><br>* feature-xxx<br>  feature-xxx-lisi<br>  feature-xxx-zhangsan<br>  main<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git status</span><br>On branch feature-xxx<br>Your branch is ahead of &#x27;origin/feature-xxx&#x27; by 1 commit.<br>  (use &quot;git push&quot; to publish your local commits)<br><br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure><p>git status可以看到feature-xxx分支上已经有了feature-xxx-zhangsan分支合并的点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git push</span><br></code></pre></td></tr></table></figure><h3 id="6-合并到功能分支的时候出现冲突怎么办"><a href="#6-合并到功能分支的时候出现冲突怎么办" class="headerlink" title="6.合并到功能分支的时候出现冲突怎么办"></a>6.合并到功能分支的时候出现冲突怎么办</h3><p>李四同样走了这个流程但是在合并到feature分支的时候遇到了麻烦，有代码冲突了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git rebase feature-xxx-lisi feature-xxx</span><br>Successfully rebased and updated refs/heads/feature-xxx.<br><span class="hljs-meta"></span><br><span class="hljs-meta">$ </span><span class="language-bash">git status</span><br>On branch feature-xxx<br>Your branch and &#x27;origin/feature-xxx&#x27; have diverged,<br>and have 1 and 1 different commits each, respectively.<br>  (use &quot;git pull&quot; to merge the remote branch into yours)<br><br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure><p>git status看到功能分支feature-xxx有落后，这时候需要拉取落后的代码到本地</p><p>注意这里不要直接使用git pull ，git pull 其实会做两个事情 git fetch + git merge , 会产生git提交记录的环线，这是我们要避免产生的事情。</p><p><strong>请使用git pull –rebase</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git pull --rebase</span><br>error: could not apply 49f99fb... lisi commit all<br>Resolve all conflicts manually, mark them as resolved with<br>&quot;git add/rm &lt;conflicted_files&gt;&quot;, then run &quot;git rebase --continue&quot;.<br>You can instead skip this commit: run &quot;git rebase --skip&quot;.<br>To abort and get back to the state before &quot;git rebase&quot;, run &quot;git rebase --abort&quot;.<br>Could not apply 49f99fb... lisi commit all<br>Auto-merging src/main/java/com/example/leetcode/editor/test/Test.java<br>CONFLICT (content): Merge conflict in src/main/java/com/example/leetcode/editor/test/Test.java<br></code></pre></td></tr></table></figure><p>可以看到出现了冲突（CONFLICT），这时候需要到idea中处理冲突</p><img src="/2022/03/08/git-rebase%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/git-rebase-lisi-fix2.gif" class="" title="图片引用方法一"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git status</span><br>On branch feature-xxx<br>Your branch is ahead of &#x27;origin/feature-xxx&#x27; by 1 commit.<br>  (use &quot;git push&quot; to publish your local commits)<br><br>nothing to commit, working tree clean<br><span class="hljs-meta"></span><br><span class="hljs-meta">$ </span><span class="language-bash">git push</span><br></code></pre></td></tr></table></figure><h2 id="rebase常见问题"><a href="#rebase常见问题" class="headerlink" title="rebase常见问题"></a>rebase常见问题</h2><h3 id="1-作为一个feature负责人，发现落后release分支太多了怎么办"><a href="#1-作为一个feature负责人，发现落后release分支太多了怎么办" class="headerlink" title="1.作为一个feature负责人，发现落后release分支太多了怎么办"></a>1.作为一个feature负责人，发现落后release分支太多了怎么办</h3><p>出现这种情况有两种原因：</p><ul><li>feature分支太久没有关注release分支的状态，导致落后release分支太多</li><li>release分支被人无脑提交，没有压点</li></ul><p>第二种情况是要<strong>极力避免</strong>的，这种不负责任的提交很可能导致各个feature分支后续的rebase提交需要解决多次冲突</p><p>第一种情况怎么解决：</p><ul><li>先尝试直接rebase release，如果没有冲突或者只需要解决一两次冲突，那么就采用直接rebase的方式。</li><li>如果rebase release方式有冲突的点很多，那么可以采用将feature分支压点然后切换到release分支使用cherry-pick的方式做代码合并，然后重新创建feature分支，或者set-up-stream重新指向远程feature分支。</li></ul><h3 id="2-有人把开发主干分支压点然后强推了怎么办"><a href="#2-有人把开发主干分支压点然后强推了怎么办" class="headerlink" title="2.有人把开发主干分支压点然后强推了怎么办"></a>2.有人把开发主干分支压点然后强推了怎么办</h3><p><em><strong>注意：使用rebase的方式，如果分支是个公共分支，那么不允许rebase，这会打乱别人本地仓库的git提交线</strong></em></p><h2 id="commit-msg规范"><a href="#commit-msg规范" class="headerlink" title="commit msg规范"></a>commit msg规范</h2><ul><li>feat：新功能（feature）</li><li>fix：bug修复</li><li>refactor：重构</li><li>test：补充单元测试</li><li>docs：补充文档</li><li>style：样式/格式，不影响业务代码 or 逻辑</li></ul><p>提交描述的时候，如果涉及多个内容，则使用1.2.3做标注</p><ol><li>做了什么</li><li>做了什么</li><li>做了什么</li></ol><h2 id="一定要注意的事情"><a href="#一定要注意的事情" class="headerlink" title="一定要注意的事情"></a>一定要注意的事情</h2><ul><li>做任何操作的<strong>前后</strong>都<strong>一定</strong>要 git  status查看工作区状态</li><li>自己的分支可以git push -f ，但是<strong>公共分支，一定不要这么做！</strong></li><li>不要对公共分支做压点操作，<strong>永远不要！</strong></li><li>使用git pull –rebase <strong>一定</strong>是正确的。尽量不要使用git pull，一有冲突就会merge</li></ul>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
