<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go语言基础备忘</title>
      <link href="/2022/041417510.html"/>
      <url>/2022/041417510.html</url>
      
        <content type="html"><![CDATA[<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//package main 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，</span><br><span class="hljs-comment">//如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">//import &quot;fmt&quot; 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">下一行 func main() 是程序开始执行的函数。</span><br><span class="hljs-comment">main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//需要注意的是 &#123; 不能单独放在一行，否则会报错</span><br>fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;init&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>NOTE</strong> :</p><ul><li> 文件名与包名没有直接关系，不一定要将文件名与包名定成同一个。</li><li> 文件夹名与包名没有直接关系，并非需要一致。</li><li> 同一个文件夹下的文件只能有一个包名，否则编译报错。</li></ul><img src="https://cdn.jsdelivr.net/gh/HMYDK/picb@main/img/image-20220414173339247.png" alt="image-20220414173339247" style="zoom:80%;" /><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><h5 id="第一种，指定变量类型，如果没有初始化，则变量默认为零值。"><a href="#第一种，指定变量类型，如果没有初始化，则变量默认为零值。" class="headerlink" title="第一种，指定变量类型，如果没有初始化，则变量默认为零值。"></a><strong>第一种，指定变量类型，如果没有初始化，则变量默认为零值</strong>。</h5><p>零值就是变量没有做初始化时系统默认设置的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 声明一个变量并初始化</span><br>    <span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;RUNOOB&quot;</span><br>    fmt.Println(a)  <span class="hljs-comment">//RUNOOB</span><br><br>    <span class="hljs-comment">// 没有初始化就为零值</span><br>    <span class="hljs-keyword">var</span> b <span class="hljs-type">int</span><br>    fmt.Println(b) <span class="hljs-comment">//0</span><br><br>    <span class="hljs-comment">// bool 零值为 false</span><br>    <span class="hljs-keyword">var</span> c <span class="hljs-type">bool</span><br>    fmt.Println(c) <span class="hljs-comment">//false</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>数值类型（包括complex64/128）为 <strong>0</strong></p></li><li><p>布尔类型为 <strong>false</strong></p></li><li><p>字符串为 **””**（空字符串）</p></li><li><p>以下几种类型为 <strong>nil</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a *<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> a []<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>] <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> a <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> a <span class="hljs-type">error</span> <span class="hljs-comment">// error 是接口</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="第二种，根据值自行判定变量类型。"><a href="#第二种，根据值自行判定变量类型。" class="headerlink" title="第二种，根据值自行判定变量类型。"></a><strong>第二种，根据值自行判定变量类型。</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> d = <span class="hljs-literal">true</span><br>    fmt.Println(d) <span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="第三种，如果变量已经使用-var-声明过了，再使用-声明变量，就产生编译错误，格式："><a href="#第三种，如果变量已经使用-var-声明过了，再使用-声明变量，就产生编译错误，格式：" class="headerlink" title="第三种，如果变量已经使用 var 声明过了，再使用 := 声明变量，就产生编译错误，格式："></a><strong>第三种，如果变量已经使用 var 声明过了，再使用 := 声明变量，就产生编译错误，格式：</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> intVal <span class="hljs-type">int</span> <br>intVal :=<span class="hljs-number">1</span> <span class="hljs-comment">// 这时候会产生编译错误，因为 intVal 已经声明，不需要重新声明</span><br></code></pre></td></tr></table></figure><p>直接使用下边的语句即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">intVal := <span class="hljs-number">1</span> <span class="hljs-comment">// 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句</span><br></code></pre></td></tr></table></figure><p><code>intVal := 1</code> 相等于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> intVal <span class="hljs-type">int</span> <br>intVal =<span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f := <span class="hljs-string">&quot;Runoob&quot;</span> <span class="hljs-comment">// var f string = &quot;Runoob&quot;</span><br>    fmt.Println(f)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>NOTE</strong>:</p><p>注意<code>:=</code>的写法，只能用于<u>非全局变量</u>的定义。</p><blockquote><p>这是使用变量的首选形式，但是它<strong>只能被用在函数体内</strong>，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/HMYDK/picb@main/img/image-20220414195154287.png" alt="image-20220414195154287"></p><h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><ul><li>局部变量声明之后必须被使用，否则编译器会报错。【声明之后只是单纯的赋值也不行，要有地方使用】</li><li>全局变量允许声明但不使用</li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p><p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><p>常量的定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> identifier [<span class="hljs-keyword">type</span>] = value<br></code></pre></td></tr></table></figure><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Unknown = <span class="hljs-number">0</span><br>    Female = <span class="hljs-number">1</span><br>    Male = <span class="hljs-number">2</span><br>)<br></code></pre></td></tr></table></figure><p>数字 0、1 和 2 分别代表未知性别、女性和男性。</p><p>常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。<strong>常量表达式中，函数必须是内置函数，否则编译不过</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unsafe&quot;</span><br><span class="hljs-keyword">const</span> (<br>    a = <span class="hljs-string">&quot;abc&quot;</span><br>    b = <span class="hljs-built_in">len</span>(a)<br>    c = unsafe.Sizeof(a)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">println</span>(a, b, c)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>基本都和<code>Java</code>一致，有区别的如下</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">返回变量的存储地址</td><td align="center">&a; 将给出变量的实际地址。</td></tr><tr><td align="center">*</td><td align="center">指针变量</td><td align="center">*a; 是一个指针变量</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">4</span><br>   <span class="hljs-keyword">var</span> b <span class="hljs-type">int32</span><br>   <span class="hljs-keyword">var</span> c <span class="hljs-type">float32</span><br>   <span class="hljs-keyword">var</span> ptr *<span class="hljs-type">int</span><br><br>   <span class="hljs-comment">/* 运算符实例 */</span><br>   fmt.Printf(<span class="hljs-string">&quot;第 1 行 - a 变量类型为 = %T\n&quot;</span>, a );<br>   fmt.Printf(<span class="hljs-string">&quot;第 2 行 - b 变量类型为 = %T\n&quot;</span>, b );<br>   fmt.Printf(<span class="hljs-string">&quot;第 3 行 - c 变量类型为 = %T\n&quot;</span>, c );<br><br>   <span class="hljs-comment">/*  &amp; 和 * 运算符实例 */</span><br>   ptr = &amp;a     <span class="hljs-comment">/* &#x27;ptr&#x27; 包含了 &#x27;a&#x27; 变量的地址 */</span><br>   fmt.Printf(<span class="hljs-string">&quot;a 的值为  %d\n&quot;</span>, a);<br>   fmt.Printf(<span class="hljs-string">&quot;*ptr 为 %d\n&quot;</span>, *ptr);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nim">第 <span class="hljs-number">1</span> 行 - a 变量类型为 = <span class="hljs-type">int</span><br>第 <span class="hljs-number">2</span> 行 - b 变量类型为 = <span class="hljs-type">int32</span><br>第 <span class="hljs-number">3</span> 行 - c 变量类型为 = <span class="hljs-type">float32</span><br>a 的值为  <span class="hljs-number">4</span><br>*<span class="hljs-keyword">ptr</span> 为 <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h4 id="amp-与"><a href="#amp-与" class="headerlink" title="&amp; 与 *"></a>&amp; 与 *</h4><p>使用指针变量与不使用的区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">4</span><br>    <span class="hljs-keyword">var</span> ptr <span class="hljs-type">int</span><br>    ptr = a <br>    fmt.Println(ptr)<span class="hljs-comment">//4</span><br>    a = <span class="hljs-number">15</span><br>    fmt.Println(ptr)<span class="hljs-comment">//4</span><br>    <br>    <span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">5</span> <br>    <span class="hljs-keyword">var</span> ptr1 *<span class="hljs-type">int</span><br>    ptr1 = &amp;b <br>    fmt.Println(*ptr1)<span class="hljs-comment">//5</span><br>    b=<span class="hljs-number">15</span> <br>    fmt.Println(*ptr1)<span class="hljs-comment">//15</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>和<code>java</code>没有区别</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><blockquote><p>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。</p><p>switch 语句执行的过程从上至下，直到找到匹配项，<u>匹配项后面也不需要再加 break</u>。</p><p>switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 <strong><code>fallthrough</code></strong> 。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 定义局部变量 */</span><br>   <span class="hljs-keyword">var</span> grade <span class="hljs-type">string</span> = <span class="hljs-string">&quot;B&quot;</span><br>   <span class="hljs-keyword">var</span> marks <span class="hljs-type">int</span> = <span class="hljs-number">90</span><br><br>   <span class="hljs-keyword">switch</span> marks &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">90</span>: grade = <span class="hljs-string">&quot;A&quot;</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-number">80</span>: grade = <span class="hljs-string">&quot;B&quot;</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-number">50</span>,<span class="hljs-number">60</span>,<span class="hljs-number">70</span> : grade = <span class="hljs-string">&quot;C&quot;</span><br>      <span class="hljs-keyword">default</span>: grade = <span class="hljs-string">&quot;D&quot;</span>  <br>   &#125;<br><br>   <span class="hljs-keyword">switch</span> &#123;<br>      <span class="hljs-keyword">case</span> grade == <span class="hljs-string">&quot;A&quot;</span> :<br>         fmt.Printf(<span class="hljs-string">&quot;优秀!\n&quot;</span> )    <br>      <span class="hljs-keyword">case</span> grade == <span class="hljs-string">&quot;B&quot;</span>, grade == <span class="hljs-string">&quot;C&quot;</span> :<br>         fmt.Printf(<span class="hljs-string">&quot;良好\n&quot;</span> )      <br>      <span class="hljs-keyword">case</span> grade == <span class="hljs-string">&quot;D&quot;</span> :<br>         fmt.Printf(<span class="hljs-string">&quot;及格\n&quot;</span> )      <br>      <span class="hljs-keyword">case</span> grade == <span class="hljs-string">&quot;F&quot;</span>:<br>         fmt.Printf(<span class="hljs-string">&quot;不及格\n&quot;</span> )<br>      <span class="hljs-keyword">default</span>:<br>         fmt.Printf(<span class="hljs-string">&quot;差\n&quot;</span> );<br>   &#125;<br>   fmt.Printf(<span class="hljs-string">&quot;你的等级是 %s\n&quot;</span>, grade );      <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">优秀!<br>你的等级是 <span class="hljs-selector-tag">A</span><br></code></pre></td></tr></table></figure><h4 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h4><p>使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-literal">false</span>:<br>            fmt.Println(<span class="hljs-string">&quot;1、case 条件语句为 false&quot;</span>)<br>            <span class="hljs-keyword">fallthrough</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-literal">true</span>:<br>            fmt.Println(<span class="hljs-string">&quot;2、case 条件语句为 true&quot;</span>)<br>            <span class="hljs-keyword">fallthrough</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-literal">false</span>:<br>            fmt.Println(<span class="hljs-string">&quot;3、case 条件语句为 false&quot;</span>)<br>            <span class="hljs-keyword">fallthrough</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-literal">true</span>:<br>            fmt.Println(<span class="hljs-string">&quot;4、case 条件语句为 true&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-literal">false</span>:<br>            fmt.Println(<span class="hljs-string">&quot;5、case 条件语句为 false&quot;</span>)<br>            <span class="hljs-keyword">fallthrough</span><br>    <span class="hljs-keyword">default</span>:<br>            fmt.Println(<span class="hljs-string">&quot;6、默认 case&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">2</span>、<span class="hljs-keyword">case</span> 条件语句为 <span class="hljs-literal">true</span><br><span class="hljs-number">3</span>、<span class="hljs-keyword">case</span> 条件语句为 <span class="hljs-literal">false</span><br><span class="hljs-number">4</span>、<span class="hljs-keyword">case</span> 条件语句为 <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><u>从以上代码输出的结果可以看出：switch 从第一个判断表达式为 true 的 case 开始执行，如果 case 带有 fallthrough，程序会继续执行下一条 case，且它<strong>不会去判断下一个 case 的表达式是否为 true</strong>。</u></p><h3 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h3><p>todo</p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>GO的for循环有三种形式，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//这种和java中的for形式上没区别，用法一致</span><br><span class="hljs-keyword">for</span> init; condition; post &#123; &#125;<br><span class="hljs-comment">//这种像是java中的 while (condition)</span><br><span class="hljs-keyword">for</span> condition &#123; &#125;<br><span class="hljs-comment">//这种像是java中的  while(true)</span><br><span class="hljs-keyword">for</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>还有一种 <code>For-each range</code> 的形式</p><p>这种格式的循环可以对字符串、数组、切片等进行迭代输出元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        strings := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;google&quot;</span>, <span class="hljs-string">&quot;runoob&quot;</span>&#125;<br>        <span class="hljs-keyword">for</span> i, s := <span class="hljs-keyword">range</span> strings &#123;<br>                fmt.Println(i, s)<br>        &#125;<br><br>        numbers := [<span class="hljs-number">6</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;<br>        <span class="hljs-keyword">for</span> i,x:= <span class="hljs-keyword">range</span> numbers &#123;<br>                fmt.Printf(<span class="hljs-string">&quot;第 %d 位 x 的值 = %d\n&quot;</span>, i,x)<br>        &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">func <span class="hljs-keyword">function</span><span class="hljs-number">_n</span>ame ([parameter list]) [<span class="hljs-keyword">return</span><span class="hljs-number">_</span>types] &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>func：函数由 func 开始声明</li><li>function_name：函数名称，参数列表和返回值类型构成了函数签名。</li><li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li><li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li></ul><p>注意：<strong>go的函数可以返回多个值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123; <span class="hljs-comment">//这里返回了两个返回值</span><br>   <span class="hljs-keyword">return</span> y, x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   a, b := swap(<span class="hljs-string">&quot;Google&quot;</span>, <span class="hljs-string">&quot;Runoob&quot;</span>)<br>   fmt.Println(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>函数如果使用参数，该变量可称为函数的形参。</p><p>形参就像定义在函数体内的局部变量。</p><p><u>默认情况下，Go 语言使用的是<strong>值传递</strong>，即在调用过程中不会影响到实际参数。</u></p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>Go 语言中变量可以在三个地方声明：</p><ul><li>函数内定义的变量称为局部变量</li><li>函数外定义的变量称为全局变量</li><li>函数定义中的变量称为形式参数</li></ul><p>Go 语言中全局变量与局部变量名称<u>可以相同</u>，但是<u>函数内的局部变量会被优先考虑</u>。实例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 声明全局变量 */</span><br><span class="hljs-keyword">var</span> g <span class="hljs-type">int</span> = <span class="hljs-number">20</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 声明局部变量 */</span><br>   <span class="hljs-keyword">var</span> g <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br><br>   fmt.Printf (<span class="hljs-string">&quot;结果： g = %d\n&quot;</span>,  g) <span class="hljs-comment">//结果： g = 10</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> variable_name [size] variable_type<br><span class="hljs-comment">//例子</span><br><span class="hljs-keyword">var</span> balance [<span class="hljs-number">10</span>] <span class="hljs-type">float32</span><br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> balance = [<span class="hljs-number">5</span>]<span class="hljs-type">float32</span>&#123;<span class="hljs-number">1000.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">50.0</span>&#125;<br><span class="hljs-comment">//也可以通过字面量在声明数组的同时快速初始化数组：</span><br>balance := [<span class="hljs-number">5</span>]<span class="hljs-type">float32</span>&#123;<span class="hljs-number">1000.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">50.0</span>&#125;<br><br><span class="hljs-comment">//如果数组长度不确定，可以使用 ... 代替数组的长度，编译器会根据元素个数自行推断数组的长度：</span><br><span class="hljs-keyword">var</span> balance = [...]<span class="hljs-type">float32</span>&#123;<span class="hljs-number">1000.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">50.0</span>&#125;<br><span class="hljs-comment">//或</span><br>balance := [...]<span class="hljs-type">float32</span>&#123;<span class="hljs-number">1000.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">50.0</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a><strong>多维数组</strong></h3><p>和<code>java</code>没什么区别</p><p><strong>NOTE:</strong></p><p>与 c 语言不同，go 的数组作为<u>函数参数传递的是副本，函数内修改数组并不改变原来的数组</u>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(nums[3] <span class="hljs-type">int</span>)</span></span>&#123;<br>   nums[<span class="hljs-number">0</span>]=<span class="hljs-number">100</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> nums=[<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;   <br>    change(nums)   <span class="hljs-comment">//nums并未被改变   </span><br>    fmt.Println(nums[<span class="hljs-number">0</span>])     <span class="hljs-comment">//结果还是1</span><br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意区分数组和切片</p><ul><li><p>Go 语言的数组是值，其长度是其类型的一部分，作为函数参数时，是 <strong>值传递</strong>，函数中的修改对调用者不可见</p></li><li><p>Go 语言中对数组的处理，一般采用 <strong>切片</strong> 的方式，切片包含对底层数组内容的引用，作为函数参数时，类似于 <strong>指针传递</strong>，函数中的修改对调用者可见</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Go 语言的数组是值，其长度是其类型的一部分，作为函数参数时，是 值传递，函数中的修改对调用者不可见</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change1</span><span class="hljs-params">(nums [3]<span class="hljs-type">int</span>)</span></span> &#123;    <br>    nums[<span class="hljs-number">0</span>] = <span class="hljs-number">4</span><br>&#125;<br><span class="hljs-comment">// 传递进来数组的内存地址，然后定义指针变量指向该地址，则会改变数组的值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change2</span><span class="hljs-params">(nums *[3]<span class="hljs-type">int</span>)</span></span> &#123;    <br>    nums[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span><br>&#125;<br><span class="hljs-comment">// Go 语言中对数组的处理，一般采用 切片 的方式，切片包含对底层数组内容的引用，作为函数参数时，类似于 指针传递，函数中的修改对调用者可见</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change3</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;    <br>    nums[<span class="hljs-number">0</span>] = <span class="hljs-number">6</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <br>    <span class="hljs-keyword">var</span> nums1 = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;   <br>    <span class="hljs-keyword">var</span> nums2 = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;    <br>    change1(nums1)    <br>    fmt.Println(nums1)  <span class="hljs-comment">//  [1 2 3]     </span><br>    change2(&amp;nums1)    <br>    fmt.Println(nums1)  <span class="hljs-comment">//  [5 2 3]    </span><br>    change3(nums2)    <br>    fmt.Println(nums2)  <span class="hljs-comment">//  [6 2 3]</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>Go 语言切片是对数组的抽象。</p><p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier []<span class="hljs-keyword">type</span><br><span class="hljs-keyword">var</span> slice1 []<span class="hljs-keyword">type</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">type</span>, <span class="hljs-built_in">len</span>)<br><span class="hljs-comment">//也可以简写为</span><br>slice1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">type</span>, <span class="hljs-built_in">len</span>)<br><span class="hljs-comment">//也可以指定容量，其中 capacity 为可选参数。</span><br><span class="hljs-comment">//这里 length 是数组的长度并且也是切片的初始长度。</span><br><span class="hljs-built_in">make</span>([]T, length, capacity)<br></code></pre></td></tr></table></figure><h3 id="len-和-cap-函数"><a href="#len-和-cap-函数" class="headerlink" title="len() 和 cap() 函数"></a><strong>len() 和 cap() 函数</strong></h3><p>切片是可索引的，并且可以由 len() 方法获取长度。</p><p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p><p>以下为具体实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> numbers = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br><br>   printSlice(numbers)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSlice</span><span class="hljs-params">(x []<span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-comment">//len=3 cap=5 slice=[0 0 0]</span><br>   fmt.Printf(<span class="hljs-string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="hljs-built_in">len</span>(x),<span class="hljs-built_in">cap</span>(x),x)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="空（nil）切片"><a href="#空（nil）切片" class="headerlink" title="空（nil）切片"></a><strong>空（nil）切片</strong></h3><p>一个切片在未初始化之前默认为 nil，长度为 0，实例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> numbers []<span class="hljs-type">int</span><br><br>   printSlice(numbers)<br><br>   <span class="hljs-keyword">if</span>(numbers == <span class="hljs-literal">nil</span>)&#123;<br>      fmt.Printf(<span class="hljs-string">&quot;切片是空的&quot;</span>)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSlice</span><span class="hljs-params">(x []<span class="hljs-type">int</span>)</span></span>&#123;<br>   fmt.Printf(<span class="hljs-string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="hljs-built_in">len</span>(x),<span class="hljs-built_in">cap</span>(x),x)<br>&#125;<br><br><span class="hljs-comment">//len=0 cap=0 slice=[]</span><br><span class="hljs-comment">//切片是空的</span><br></code></pre></td></tr></table></figure><h3 id="切片截取"><a href="#切片截取" class="headerlink" title="切片截取"></a>切片截取</h3><p>可以通过设置下限及上限来设置截取切片 *[lower-bound:upper-bound]*，实例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 创建切片 */</span><br>   numbers := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;  <br>   printSlice(numbers) <span class="hljs-comment">//len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]</span><br><br>   <span class="hljs-comment">/* 打印原始切片 */</span><br>   fmt.Println(<span class="hljs-string">&quot;numbers ==&quot;</span>, numbers) <span class="hljs-comment">//numbers == [0 1 2 3 4 5 6 7 8]</span><br><br>   <span class="hljs-comment">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span><br>   fmt.Println(<span class="hljs-string">&quot;numbers[1:4] ==&quot;</span>, numbers[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]) <span class="hljs-comment">//numbers[1:4] == [1 2 3]</span><br><br>   <span class="hljs-comment">/* 默认下限为 0*/</span><br>   fmt.Println(<span class="hljs-string">&quot;numbers[:3] ==&quot;</span>, numbers[:<span class="hljs-number">3</span>]) <span class="hljs-comment">//numbers[:3] == [0 1 2]</span><br><br>   <span class="hljs-comment">/* 默认上限为 len(s)*/</span><br>   fmt.Println(<span class="hljs-string">&quot;numbers[4:] ==&quot;</span>, numbers[<span class="hljs-number">4</span>:]) <span class="hljs-comment">//numbers[4:] == [4 5 6 7 8]</span><br><br>   numbers1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)<br>   printSlice(numbers1) <span class="hljs-comment">//len=0 cap=5 slice=[]</span><br><br>   <span class="hljs-comment">/* 打印子切片从索引  0(包含) 到索引 2(不包含) */</span><br>   number2 := numbers[:<span class="hljs-number">2</span>]<br>   printSlice(number2) <span class="hljs-comment">//len=2 cap=9 slice=[0 1]</span><br><br>   <span class="hljs-comment">/* 打印子切片从索引 2(包含) 到索引 5(不包含) */</span><br>   number3 := numbers[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br>   printSlice(number3) <span class="hljs-comment">//len=3 cap=7 slice=[2 3 4]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSlice</span><span class="hljs-params">(x []<span class="hljs-type">int</span>)</span></span>&#123;<br>   fmt.Printf(<span class="hljs-string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="hljs-built_in">len</span>(x),<span class="hljs-built_in">cap</span>(x),x)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="append-和-copy-函数"><a href="#append-和-copy-函数" class="headerlink" title="append() 和 copy() 函数"></a>append() 和 copy() 函数</h3><p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p><p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> numbers []<span class="hljs-type">int</span><br>   printSlice(numbers) <span class="hljs-comment">//len=0 cap=0 slice=[]</span><br><br>   <span class="hljs-comment">/* 允许追加空切片 */</span><br>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">0</span>)<br>   printSlice(numbers) <span class="hljs-comment">//len=1 cap=1 slice=[0]</span><br><br>   <span class="hljs-comment">/* 向切片添加一个元素 */</span><br>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">1</span>)<br>   printSlice(numbers) <span class="hljs-comment">//len=2 cap=2 slice=[0 1]</span><br><br>   <span class="hljs-comment">/* 同时添加多个元素 */</span><br>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>   printSlice(numbers) <span class="hljs-comment">//len=5 cap=6 slice=[0 1 2 3 4]</span><br><br>   <span class="hljs-comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span><br>   numbers1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(numbers), (<span class="hljs-built_in">cap</span>(numbers))*<span class="hljs-number">2</span>)<br><br>   <span class="hljs-comment">/* 拷贝 numbers 的内容到 numbers1 */</span><br>   <span class="hljs-built_in">copy</span>(numbers1,numbers)<br>   printSlice(numbers1)  <span class="hljs-comment">//len=5 cap=12 slice=[0 1 2 3 4]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSlice</span><span class="hljs-params">(x []<span class="hljs-type">int</span>)</span></span>&#123;<br>   fmt.Printf(<span class="hljs-string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="hljs-built_in">len</span>(x),<span class="hljs-built_in">cap</span>(x),x)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Map（集合）"><a href="#Map（集合）" class="headerlink" title="Map（集合）"></a>Map（集合）</h2><h3 id="定义Map"><a href="#定义Map" class="headerlink" title="定义Map"></a>定义Map</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 声明变量，默认 map 是 nil */</span><br><span class="hljs-keyword">var</span> map_variable <span class="hljs-keyword">map</span>[key_data_type]value_data_type<br><br><span class="hljs-comment">/* 使用 make 函数 */</span><br>map_variable := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[key_data_type]value_data_type)<br></code></pre></td></tr></table></figure><p><u>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</u></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> countryCapitalMap <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span> <span class="hljs-comment">/*创建集合 */</span><br>    countryCapitalMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br><br>    <span class="hljs-comment">/* map插入key - value对,各个国家对应的首都 */</span><br>    countryCapitalMap [ <span class="hljs-string">&quot;France&quot;</span> ] = <span class="hljs-string">&quot;巴黎&quot;</span><br>    countryCapitalMap [ <span class="hljs-string">&quot;Italy&quot;</span> ] = <span class="hljs-string">&quot;罗马&quot;</span><br>    countryCapitalMap [ <span class="hljs-string">&quot;Japan&quot;</span> ] = <span class="hljs-string">&quot;东京&quot;</span><br>    countryCapitalMap [ <span class="hljs-string">&quot;India &quot;</span> ] = <span class="hljs-string">&quot;新德里&quot;</span><br><br>    <span class="hljs-comment">/*使用键输出地图值 */</span><br>    <span class="hljs-keyword">for</span> country := <span class="hljs-keyword">range</span> countryCapitalMap &#123;<br>        fmt.Println(country, <span class="hljs-string">&quot;首都是&quot;</span>, countryCapitalMap [country])<br>    &#125;<br><br>    <span class="hljs-comment">/*查看元素在集合中是否存在 */</span><br>    capital, ok := countryCapitalMap [ <span class="hljs-string">&quot;American&quot;</span> ] <span class="hljs-comment">/*如果确定是真实的,则存在,否则不存在 */</span><br>    <span class="hljs-comment">/*fmt.Println(capital) */</span><br>    <span class="hljs-comment">/*fmt.Println(ok) */</span><br>    <span class="hljs-keyword">if</span> (ok) &#123;<br>        fmt.Println(<span class="hljs-string">&quot;American 的首都是&quot;</span>, capital)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;American 的首都不存在&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="delete-函数"><a href="#delete-函数" class="headerlink" title="delete()函数"></a>delete()函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(countryCapitalMap, <span class="hljs-string">&quot;France&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p>Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//这是我们使用range去求一个slice的和。使用数组跟这个很类似</span><br>    nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += num<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;sum:&quot;</span>, sum)<br>    <span class="hljs-comment">//在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符&quot;_&quot;省略了。有时侯我们确实需要知道它的索引。</span><br>    <span class="hljs-keyword">for</span> i, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> num == <span class="hljs-number">3</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;index:&quot;</span>, i)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//range也可以用在map的键值对上。</span><br>    kvs := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-string">&quot;banana&quot;</span>&#125;<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> kvs &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%s -&gt; %s\n&quot;</span>, k, v)<br>    &#125;<br>    <span class="hljs-comment">//range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。</span><br>    <span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> <span class="hljs-string">&quot;go&quot;</span> &#123;<br>        fmt.Println(i, c)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span>= <span class="hljs-number">20</span>   <span class="hljs-comment">/* 声明实际变量 */</span><br>   <span class="hljs-keyword">var</span> ip *<span class="hljs-type">int</span>        <span class="hljs-comment">/* 声明指针变量 */</span><br><br>   ip = &amp;a  <span class="hljs-comment">/* 指针变量的存储地址 */</span><br><br>   fmt.Printf(<span class="hljs-string">&quot;a 变量的地址是: %x\n&quot;</span>, &amp;a  )<br><br>   <span class="hljs-comment">/* 指针变量的存储地址 */</span><br>   fmt.Printf(<span class="hljs-string">&quot;ip 变量储存的指针地址: %x\n&quot;</span>, ip )<br><br>   <span class="hljs-comment">/* 使用指针访问值 */</span><br>   fmt.Printf(<span class="hljs-string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip )<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">a 变量的地址是</span><span class="hljs-punctuation">:</span> <span class="hljs-string">20818a220</span><br><span class="hljs-attribute">ip 变量储存的指针地址</span><span class="hljs-punctuation">:</span> <span class="hljs-string">20818a220</span><br><span class="hljs-attribute">*ip 变量的值</span><span class="hljs-punctuation">:</span> <span class="hljs-string">20</span><br></code></pre></td></tr></table></figure><h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p>当一个指针被定义后没有分配到任何变量时，它的值为 nil。</p><p>nil 指针也称为空指针。</p><p>nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span>(ptr != <span class="hljs-literal">nil</span>)     <span class="hljs-comment">/* ptr 不是空指针 */</span><br><span class="hljs-keyword">if</span>(ptr == <span class="hljs-literal">nil</span>)    <span class="hljs-comment">/* ptr 是空指针 */</span><br></code></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>注意一般写法传到函数中的是对象拷贝，函数内的修改不会反映到源对象中。</p><p>需要明确指针传递，函数内修改之后，函数外才可见。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Books <span class="hljs-keyword">struct</span> &#123;<br>    title <span class="hljs-type">string</span><br>    author <span class="hljs-type">string</span><br>    subject <span class="hljs-type">string</span><br>    book_id <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">changeBook</span><span class="hljs-params">(book *Books)</span></span> &#123;<br>    book.title = <span class="hljs-string">&quot;book1_change&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结构体中属性的首字母大小写问题</strong></p><ul><li> 首字母大写相当于 public。</li><li> 首字母小写相当于 private。</li></ul><p><strong>注意:</strong> 这个 public 和 private 是相对于包（go 文件首行的 package 后面跟的包名）来说的。</p><p><strong>敲黑板，划重点</strong></p><p>当要将结构体对象转换为 JSON 时，对象中的属性首字母必须是大写，才能正常转换为 JSON。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Age   <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span><br>grade <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;grade&quot;`</span> <span class="hljs-comment">//因为首字母小写，所以不会被解析</span><br>Phone <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;-&quot;`</span>     <span class="hljs-comment">//标记忽略该字段，不会被解析</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>person := Person&#123;<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">100</span>, <span class="hljs-number">123456789</span>&#125;<br><span class="hljs-comment">// 序列化</span><br>data, err := json.Marshal(person)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;序列化失败&quot;</span>, err)<br>&#125;<br>fmt.Println(<span class="hljs-type">string</span>(data))   <span class="hljs-comment">//&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:18&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换用于将一种数据类型的变量转换为另外一种类型的变量。Go 语言类型转换基本格式如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span><span class="hljs-constructor">_name(<span class="hljs-params">expression</span>)</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span> = <span class="hljs-number">17</span><br>   <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span> = <span class="hljs-number">5</span><br>   <span class="hljs-keyword">var</span> mean <span class="hljs-type">float32</span><br>   <br>   mean = <span class="hljs-type">float32</span>(sum)/<span class="hljs-type">float32</span>(count)<br>   fmt.Printf(<span class="hljs-string">&quot;mean 的值为: %f\n&quot;</span>,mean)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-Djiango备忘</title>
      <link href="/2022/04089069.html"/>
      <url>/2022/04089069.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.djangoproject.com/zh-hans/4.0/">官方文档</a></p><h4 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h4><p>model.py中创建model结束之后，执行以下命令将变更同步到数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"> python .\manage.py makemigrations<br>python .\manage.py mograte<br></code></pre></td></tr></table></figure><p>执行完之后检查数据库是否做了变更同步</p><h4 id="F-amp-Q"><a href="#F-amp-Q" class="headerlink" title="F&amp;Q"></a>F&amp;Q</h4><h5 id="F"><a href="#F" class="headerlink" title="F"></a>F</h5><img src="https://cdn.jsdelivr.net/gh/HMYDK/picb@main/img/image-20220409160741869.png" alt="image-20220409160741869" style="zoom: 67%;" /><h5 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h5><img src="https://cdn.jsdelivr.net/gh/HMYDK/picb@main/img/image-20220409160537752.png" alt="image-20220409160537752" style="zoom:67%;" /><h5 id="原生sql"><a href="#原生sql" class="headerlink" title="原生sql"></a>原生sql</h5><p>django的orm还是需要一点点时间成本去学习的，单纯作为一个工具框架来用的话，大多数人可能更倾向于原生sql，我本人就是如此。</p><p><a href="https://docs.djangoproject.com/zh-hans/4.0/topics/db/sql/">执行原生 SQL 查询</a></p><p>这里有一点要注意，那就是sql注入，这也是直接使用原生sql而不是使用orm可能带来的问题。djanggo建议我们使用原生sql的时候不要直接拼接一个完整的sql到row()中执行，而是使用row(sql，parma)的方式执行，这样可以避免sql注入的问题产生。</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/2022/040423896.html"/>
      <url>/2022/040423896.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 反向代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode常用技巧/算法汇总</title>
      <link href="/2022/031820106.html"/>
      <url>/2022/031820106.html</url>
      
        <content type="html"><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><blockquote><p><strong>贪心算法</strong>（英语：greedy algorithm），又称<strong>贪婪算法</strong>，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95">算法</a>。[<a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95#cite_note-paike-1">1]</a>比如在<a href="https://zh.wikipedia.org/wiki/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98">旅行推销员问题</a>中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。</p><p>贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。</p><p>贪心算法与<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a>的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p><p>贪心法可以解决一些<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BC%98%E5%8C%96">最优化</a>问题，如：求<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE">图</a>中的<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">最小生成树</a>、求<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">哈夫曼编码</a>……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。在不同情况，选择最优的解，可能会导致辛普森悖论（Simpson’s Paradox），不一定出现最优的解。</p><p>贪心算法在数据科学领域被广泛应用，特别是金融工程。其中一个贪心算法例子就是Ensemble method。</p></blockquote><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><table><thead><tr><th align="center">题目</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></td><td align="center">中等</td></tr></tbody></table><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h4 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h4><blockquote><p>滑动窗口指的是这样一类问题的求解方法，在数组上通过双指针同向移动而解决的一类问题。其实这样的问题我们可以不必为它们专门命名一个名字，它们的解法其实是很自然的。</p><p>使用滑动窗口解决的问题通常是暴力解法的优化，掌握这一类问题最好的办法就是练习，然后思考清楚为什么可以使用滑动窗口。</p></blockquote><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><a href="https://leetcode-cn.com/tag/sliding-window/problemset/">leetcode题库</a></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>问答:RocketMQ</title>
      <link href="/2022/031526519.html"/>
      <url>/2022/031526519.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于RocketMQ v4.5.0之前的版本</p></blockquote><h4 id="Q：RocketMQ由哪些角色组成，每个角色作用和特点是什么？"><a href="#Q：RocketMQ由哪些角色组成，每个角色作用和特点是什么？" class="headerlink" title="Q：RocketMQ由哪些角色组成，每个角色作用和特点是什么？"></a>Q：RocketMQ由哪些角色组成，每个角色作用和特点是什么？</h4><table><thead><tr><th align="center">角色</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">NameServer</td><td align="center">无状态，动态列表；这也是和zookeeper的重要区别之一。zookeeper是有状态的。</td></tr><tr><td align="center">Producer</td><td align="center">消息生产者，负责发消息到Broker。</td></tr><tr><td align="center">Broker</td><td align="center">就是MQ本身，负责收发消息、持久化消息等。</td></tr><tr><td align="center">Consumer</td><td align="center">消息消费者，负责从Broker上拉取消息进行消费，消费完进行ack。</td></tr></tbody></table><h4 id="Q：RocketMQ-Broker中的消息被消费后会立即删除吗？"><a href="#Q：RocketMQ-Broker中的消息被消费后会立即删除吗？" class="headerlink" title="Q：RocketMQ Broker中的消息被消费后会立即删除吗？"></a>Q：RocketMQ Broker中的消息被消费后会立即删除吗？</h4><p>不会，每条消息都会持久化到<code>CommitLog</code>中，每个<code>Consumer</code>连接到<code>Broker</code>后会维持消费进度信息，当有消息消费后只是当前<code>Consumer</code>的消费进度（CommitLog的offset）更新了。</p><p>4.6版本默认48小时后会删除不再使用的CommitLog文件</p><ul><li>检查这个文件最后访问时间</li><li>判断是否大于过期时间</li><li>指定时间删除，默认凌晨4点</li></ul><h4 id="Q：RocketMQ消息是push还是pull？"><a href="#Q：RocketMQ消息是push还是pull？" class="headerlink" title="Q：RocketMQ消息是push还是pull？"></a>Q：RocketMQ消息是push还是pull？</h4><ul><li>RocketMQ没有真正意义的push，都是pull，虽然有push类，但实际底层实现采用的是<strong>长轮询机制</strong>，即拉取方式。</li><li>broker端属性 longPollingEnable 标记是否开启长轮询。默认开启</li></ul><h4 id="Q：为什么要主动拉取消息而不使用事件监听方式？"><a href="#Q：为什么要主动拉取消息而不使用事件监听方式？" class="headerlink" title="Q：为什么要主动拉取消息而不使用事件监听方式？"></a>Q：为什么要主动拉取消息而不使用事件监听方式？</h4><p>事件驱动方式是建立好长连接，由事件（发送数据）的方式来实时推送。</p><p>如果<code>broker</code>主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成<u>消息在 <code>Consumer</code> 端堆积过多，同时又不能被其他 <code>Consumer</code> 消费</u>的情况。而 pull 的方式可以根据当前自身情况来 pull，不会造成过多的压力而造成瓶颈。所以采取了 pull 的方式。</p><h4 id="Q：路由注册机制"><a href="#Q：路由注册机制" class="headerlink" title="Q：路由注册机制"></a>Q：路由注册机制</h4><img src="https://cdn.jsdelivr.net/gh/HMYDK/picb@main/img/image-20220314165017030.png" alt="image-20220314165017030" style="zoom: 50%;" /><ul><li>集群中所有的<code>Broker</code>每隔30s向所有的<code>NameServer</code>发送心跳包，<u>注册Topic路由信息</u>。</li><li><code>NameServer</code>在收到Broker端的心跳包时首先会<u>更新路由表，并记录收到心跳包的时间</u>。</li><li><code>NameServer</code>会启动一个定时任务每10s会扫描<code>Broker</code>，如果<code>NameServer</code>连续120s未收到<code>Broker</code>的心跳包，会判定<code>Broker</code>已下线，将从路由表中将此<code>Broker</code>剔除。</li><li>如果 <code>Nameserver</code> 与 <code>Broker</code> 端的长连接断开，<code>NameServer</code> 会立即感知 <code>Broker</code> 下线并从路由表中将该 <code>Broker</code> 移除。</li><li>消息客户端(消息发送者、消息消费者)在任意时刻<u>只会和其中一台</u> <code>NameServer</code> 建立 连接，并每隔 30s 向 <code>NameServer</code> 查询路由信息，如果查询到结果会<u>更新发送者的 本地路由信息</u>。</li></ul><h4 id="Q：broker主从服务器都在运行过程中，消息消费是从主节点拉取还是从节点拉取？"><a href="#Q：broker主从服务器都在运行过程中，消息消费是从主节点拉取还是从节点拉取？" class="headerlink" title="Q：broker主从服务器都在运行过程中，消息消费是从主节点拉取还是从节点拉取？"></a>Q：broker主从服务器都在运行过程中，消息消费是从主节点拉取还是从节点拉取？</h4><p>A：默认情况下，RocketMQ 消息消费者从<code>master</code>服务器拉取，当<code>master</code>服务器积压的消息超 过了物理内存的 40%，则建议从<code>slave</code>服务器拉取。但如果 slaveReadEnable 为 false，表示<code>slave</code>服务器不可读，<code>slave</code>服务器也不会接管消息拉取。</p><h4 id="Q：当消息消费者向slave服务器拉取消息后，会一直从slave服务器拉取？"><a href="#Q：当消息消费者向slave服务器拉取消息后，会一直从slave服务器拉取？" class="headerlink" title="Q：当消息消费者向slave服务器拉取消息后，会一直从slave服务器拉取？"></a>Q：当消息消费者向slave服务器拉取消息后，会一直从slave服务器拉取？</h4><p>A：不是的，分如下情况：</p><ol><li>如果<code>slave</code>服务器的 slaveReadEnable 设置为 false，则下次拉取，从<code>masrer</code>服务器拉取。 </li><li>如果<code>slave</code>服务器允许读取并且<code>slave</code>服务器积压的消息未超过其物理内存的 40%，下次拉取使用的 Broker 为订阅组的 brokerId 指定的 Broker 服务器，该值默认为 0，代表<code>master</code>服务器。</li><li>如果<code>slave</code>服务器允许读取并且<code>slave</code>服务器积压的消息超过了其物理内存的 40%，下次拉取使用的 Broker 为订阅组的 whichBrokerWhenConsumeSlowly 指定的 Broker 服 务器，该值默认为 1，代表<code>master</code>服务器。</li></ol><h4 id="Q：broker主从节点的消费进度是如何同步的？"><a href="#Q：broker主从节点的消费进度是如何同步的？" class="headerlink" title="Q：broker主从节点的消费进度是如何同步的？"></a>Q：broker主从节点的消费进度是如何同步的？</h4><p>A：</p><ul><li>消息消费进度的同步是单向的，<code>slave</code>服务器开启一个定时任务，定时从<code>master</code>服务器同步 消息消费进度；</li><li>无论消息消费者是从<code>master</code>服务器拉的消息还是从<code>slave</code>服务器拉取的消息，在向 Broker 反馈消息消费进度时，优先向<code>master</code>服务器汇报；</li><li>消息消费者向<code>master</code>服务器拉取消息时， 如果消息消费者内存中存在消息消费进度时，<code>masrer</code>会尝试更新消息消费进度。</li></ul><h4 id="Q：消息发送是如何实现高可用的？"><a href="#Q：消息发送是如何实现高可用的？" class="headerlink" title="Q：消息发送是如何实现高可用的？"></a>Q：消息发送是如何实现高可用的？</h4><blockquote><p>如果 Broker 端收到内存抖动等因素造成单条写入数据发生抖动，单个Broker 端积压的请求太大还得不到及时处理，会极大的造成客户端消息发送的延长时间，设想一下，如果由于 Broker 压力增大，写入一条消息需要 500ms 甚至超过1s，并且队列中积压了5000 条消息，消息发送端的默认超时时间为 3s，如果按照这样的速度，这些请求在轮到Broker 执行写入请求时，客户端已经将这个请求超时了，这样不仅会造成大量的无效处理，还会导致客户端发送超时。</p></blockquote><p>Broker端快速失败原理如下：</p><img src="https://cdn.jsdelivr.net/gh/HMYDK/picb@main/img/image-20220315141506789.png" alt="image-20220315141506789" style="zoom:80%;" /><ul><li>消息发送者向 Broker 发送消息写入请求，Broker 端在接收到请求后会首先放入一个队列中(SendThreadPoolQueue)，默认容量为 <u>10000</u>。</li><li>Broker 会专门使用一个线程池(SendMessageExecutor)去从队列中获取任务并执行消息写入请求，为了保证消息的顺序处理，该线程池默认线程个数为<u>1</u>。</li><li>开启一个定时调度线程，每隔 10 毫秒去检查队列中的第一个排队节点，如果该节点的排队时间已经超过了200 ms，就会取消该队列中所有已超过 200ms 的请求，立即向客户端返回失败，这样<u>客户端能尽快进行重试</u>，因为 Broker 都是集群部署，下次重试可以发送到其他Broker 上，这样能最大程度保证消息发送在默认 3s 的时间内经过重试机制，能有效避免某一台Broker 由于瞬时压力大而造成的消息发送不可用，从而实现消息发送的高可用。</li><li>业务上我们在发送消息时，应该做好异常捕获，将失败消息入库，借助定时任务做重试。</li></ul><h4 id="Q：RocketMQ路由寻找流程"><a href="#Q：RocketMQ路由寻找流程" class="headerlink" title="Q：RocketMQ路由寻找流程"></a>Q：RocketMQ路由寻找流程</h4><img src="https://cdn.jsdelivr.net/gh/HMYDK/picb@main/img/image-20220315161613014.png" alt="image-20220315161613014" style="zoom:80%;" /><ul><li>如果 <code>Broker</code> 开启了自动创建 Topic，在启动的时候会默认创建主题：<code>TBW102</code>，并会随着 <code>Broker</code> 发送到 <code>Nameserver</code> 的心跳包汇报给 <code>Nameserver</code>，继而从<code>Nameserver</code> 查询路由信息时能返回路由信息。 </li><li>消息发送者在消息发送时首先会查本地缓存，如果本地缓存中存在，直接返回路由信息。</li><li>如果缓存不存在，则向 <code>Nameserver</code> 查询路由信息，如果 <code>Nameserver</code> 存在该路由信息，就直接返回。 </li><li>如果 <code>Nameserver</code> 不存在该 topic 的路由信息，如果没有开启自动创建主题，则抛出No route info of this topic。 </li><li>如果开启了自动创建主题，则使用默认主题向 <code>Nameserver</code> 查询路由信息，并使用默认 Topic 的路由信息为自己的路由信息，将不会抛出 No route info of this topic。</li></ul><h4 id="Q：RocketMQ如何做负载均衡的？"><a href="#Q：RocketMQ如何做负载均衡的？" class="headerlink" title="Q：RocketMQ如何做负载均衡的？"></a>Q：RocketMQ如何做负载均衡的？</h4><p><u>通过Topic在多Broker中分布式存储实现</u>。</p><p><strong>producer端</strong></p><p>发送端指定 <code>message queue</code>发送消息到相应的 broker，来达到写入时的负载均衡</p><ul><li>提升写入吞吐量，当多个<code>producer</code>同时向一个 <code>broker</code> 写入数据的时候，性能会下降</li><li>消息分布在多 <code>broker</code> 中，为负载消费做准备</li></ul><p>默认策略是<code>随机选择</code>：</p><ul><li>producer 维护一个 index</li><li>每次取节点会自增</li><li>index 向所有 broker 个数取余</li><li>自带容错策略</li></ul><p><strong>consumer端</strong></p><p>采用的是平均分配算法来进行负载均衡。</p><p><strong>其他负载均衡算法</strong></p><ul><li>平均分配策略(<strong>默认</strong>)(AllocateMessageQueueAveragely)</li><li>环形分配策略(AllocateMessageQueueAveragelyByCircle)</li><li>手动配置分配策略(AllocateMessageQueueByConfig)</li><li>机房分配策略(AllocateMessageQueueByMachineRoom)</li><li>一致性哈希分配策略(AllocateMessageQueueConsistentHash)</li><li>靠近机房策略(AllocateMachineRoomNearby)</li></ul><h4 id="Q：当消费负载均衡consumer和queue不对等的时候会发生什么？"><a href="#Q：当消费负载均衡consumer和queue不对等的时候会发生什么？" class="headerlink" title="Q：当消费负载均衡consumer和queue不对等的时候会发生什么？"></a>Q：当消费负载均衡consumer和queue不对等的时候会发生什么？</h4><p>Consumer 和 queue 会优先平均分配。</p><ul><li>如果 Consumer 少于 queue 的个数，则会存在部分 Consumer 消费多个 queue 的情况</li><li>如果 Consumer 等于 queue 的个数，那就是一个 Consumer 消费一个 queue</li><li>如果 Consumer 个数大于 queue 的个数，那么会有部分 Consumer 空余出来，白白的浪费了</li></ul><h4 id="Q：消息重复消费如何解决？"><a href="#Q：消息重复消费如何解决？" class="headerlink" title="Q：消息重复消费如何解决？"></a>Q：消息重复消费如何解决？</h4><p>影响消息正常发送和消费的<strong>重要原因是网络的不确定性。</strong></p><p><strong>引起重复消费的原因</strong></p><ul><li><p><strong>ACK</strong><br>正常情况下在<code>consumer</code>真正消费完消息后应该发送<code>ack</code>，通知<code>broker</code>该消息已正常消费，从<code>queue</code>中剔除</p><p>当<code>ack</code>因为网络原因无法发送到<code>broker</code>，<code>broker</code>会认为词条消息没有被消费，此后会开启消息重投机制把消息再次投递到<code>consumer</code></p></li><li><p><strong>消费模式</strong><br>在<code>CLUSTERING</code>模式下，消息在<code>broker</code>中会保证相同<code>group</code>的<code>consumer</code>消费一次，但是针对不同<code>group</code>的<code>consumer</code>会推送多次</p></li></ul><p><strong>解决方案</strong></p><ul><li><p>数据库表：处理消息前，使用消息主键在表中带有约束的字段中insert</p></li><li><p>Map：单机时可以使用map ConcurrentHashMap -&gt; putIfAbsent guava cache</p></li><li><p>Redis：分布式锁搞起来。</p></li></ul><h4 id="Q：RocketMQ如何保证消息不丢失？"><a href="#Q：RocketMQ如何保证消息不丢失？" class="headerlink" title="Q：RocketMQ如何保证消息不丢失？"></a>Q：RocketMQ如何保证消息不丢失？</h4><p>首先在如下三个部分都可能会出现丢失消息的情况：Producer端，Broker端，Consumer端</p><h5 id="Producer端保证消息不丢失"><a href="#Producer端保证消息不丢失" class="headerlink" title="Producer端保证消息不丢失"></a>Producer端保证消息不丢失</h5><ul><li><p>采取send()同步发消息，发送结果是同步感知的。</p></li><li><p>发送失败后可以重试，设置重试次数。默认3次。</p><p><code>producer.setRetryTimesWhenSendFailed(10);</code></p></li><li><p>集群部署，比如发送失败了的原因可能是当前Broker宕机了，重试的时候会发送到其他Broker上。</p></li></ul><h5 id="Broker端保证消息不丢失"><a href="#Broker端保证消息不丢失" class="headerlink" title="Broker端保证消息不丢失"></a>Broker端保证消息不丢失</h5><ul><li><p>修改刷盘策略为同步刷盘。默认情况下是异步刷盘的。</p><p><code>flushDiskType = SYNC_FLUSH</code></p></li><li><p>集群部署，主从模式，高可用。</p></li></ul><p><strong>Consumer端保证消息不丢失</strong></p><ul><li>完全正常消费之后进行手动ack确认</li></ul><h4 id="Q：RocketMQ的消息堆积如何处理？"><a href="#Q：RocketMQ的消息堆积如何处理？" class="headerlink" title="Q：RocketMQ的消息堆积如何处理？"></a>Q：RocketMQ的消息堆积如何处理？</h4><p>首先要找到是什么原因导致的消息堆积，是<code>Producer</code>太多了还是<code>Consumer</code>太少了或者其他情况，总之先定位一个大概的问题。</p><p>再看下消息的消费速度是否正常，正常的话，那就上线更多的<code>Consumer</code>临时解决消息堆积的问题。</p><h4 id="Q：堆积消息会超时删除么？"><a href="#Q：堆积消息会超时删除么？" class="headerlink" title="Q：堆积消息会超时删除么？"></a>Q：堆积消息会超时删除么？</h4><p>不会，RocketMQ中的消息只会在commitLog被删除的时候才会消失。也就是说未消费的消息不会存在超时删除这种情况。</p><h4 id="Q：堆积的消息会不会进死信队列？"><a href="#Q：堆积的消息会不会进死信队列？" class="headerlink" title="Q：堆积的消息会不会进死信队列？"></a>Q：堆积的消息会不会进死信队列？</h4><p>不会，消息在消费失败之后会进入重试队列（%RETRY%+ConsumerGroup），18次才会进入死信队列（%DLQ%+ConsumerGroup）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageStoreConfig</span> &#123;<br>    <span class="hljs-comment">// 每隔如下时间会进行重试，到最后一次时间重试失败的话就进入死信队列了。</span><br> <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">messageDelayLevel</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Q：RocketMQ-在分布式事务支持这块机制的底层原理"><a href="#Q：RocketMQ-在分布式事务支持这块机制的底层原理" class="headerlink" title="Q：RocketMQ 在分布式事务支持这块机制的底层原理?"></a>Q：RocketMQ 在分布式事务支持这块机制的底层原理?</h4><p>分布式系统中的事务可以使用<code>TCC</code>（Try、Confirm、Cancel）、<code>2pc</code>来解决分布式系统中的消息原子性</p><p>RocketMQ 4.3+ 提供分布事务功能，通过 RocketMQ 事务消息能达到分布式事务的最终一致</p><p><strong>RocketMQ实现方式：</strong></p><ul><li><strong>Half Message</strong>：<br>预处理消息，当<code>broker</code>收到此类消息后，会存储到<code>RMQ_SYS_TRANS_HALF_TOPIC</code>的消息消费队列中</li><li><strong>检查事务状态</strong>：<br><code>Broker</code>会开启一个定时任务，消费<code>RMQ_SYS_TRANS_HALF_TOPIC</code>队列中的消息，每次执行任务会向消息发送者确认事务执行状态（提交、回滚、未知），如果是未知，<code>Broker</code>会定时去回调在重新检查。</li><li><strong>超时</strong>：<br>如果超过回查次数，默认回滚消息。</li></ul><p><u>也就是事务消息并未真正进入Topic的queue，而是用了临时queue来放所谓的half message，等提交事务后才会真正的将half message转移到topic下的queue。</u></p><h4 id="Q：高吞吐量下如何优化生产者和消费者的性能"><a href="#Q：高吞吐量下如何优化生产者和消费者的性能" class="headerlink" title="Q：高吞吐量下如何优化生产者和消费者的性能?"></a>Q：高吞吐量下如何优化生产者和消费者的性能?</h4><ul><li>开发<ul><li>同一group下，多机部署，并行消费</li><li>单个Consumer提高消费线程个数</li><li>批量消费<ul><li>消息批量拉取</li><li>业务逻辑批量处理</li></ul></li></ul></li><li>运维<ul><li>网卡调优</li><li>jvm调优</li><li>多线程与cpu调优</li><li>Page Cache</li></ul></li></ul><h4 id="Q：任何一台Broker突然宕机了怎么办？"><a href="#Q：任何一台Broker突然宕机了怎么办？" class="headerlink" title="Q：任何一台Broker突然宕机了怎么办？"></a>Q：任何一台Broker突然宕机了怎么办？</h4><p><code>Broker</code>主从架构以及多副本策略。<code>Master</code> 收到消息后会同步给 <code>Slave</code>，这样一条消息就不止一份了，<code>Master</code> 宕机了还有 <code>slave</code> 中的消息可用，保证了MQ的可靠性和高可用性。而且 Rocket MQ4.5.0 开始就支持了 <code>Dlegder</code> 模式，基于 <code>raft</code>的，做到了真正意义的 <code>HA</code>(highly available)。</p><h4 id="Q：Master-Broker-突然挂了，这样会怎么样？"><a href="#Q：Master-Broker-突然挂了，这样会怎么样？" class="headerlink" title="Q：Master Broker 突然挂了，这样会怎么样？"></a>Q：Master Broker 突然挂了，这样会怎么样？</h4><p><strong>RocketMQ 4.5 版本之前</strong>，用 Slave Broker 同步数据，尽量保证数据不丢失，但是一旦 Master 故障了，Slave 是没法自动切换成 Master 的。<br>所以在这种情况下，如果 Master Broker 宕机了，这时就得手动做一些运维操作，把 Slave Broker 重新修改一些配置，重启机器给调整为Master Broker，这是有点麻烦的，而且会导致中间一段时间不可用。</p><p><strong>RocketMQ 4.5之后</strong>支持了一种叫做 Dledger 机制，基于 Raft 协议实现的一个机制。<br>我们可以让一个 Master Broker 对应多个 Slave Broker， 一旦 Master Broker 宕机了，在多个 Slave 中通过 Dledger 技术 将一个 Slave Broker 选为新的 Master Broker 对外提供服务。<br>在生产环境中可以是用 Dledger 机制实现自动故障切换，只要10秒或者几十秒的时间就可以完成</p><h4 id="Q：Broker把自己的信息注册到哪个NameServer上？"><a href="#Q：Broker把自己的信息注册到哪个NameServer上？" class="headerlink" title="Q：Broker把自己的信息注册到哪个NameServer上？"></a>Q：Broker把自己的信息注册到哪个NameServer上？</h4><p>每个<code>Broker</code>向所有的<code>NameServer</code>上注册自己的信息，即每个<code>NameServer</code>上有所有的<code>Broker</code>信息</p><h4 id="Q：NameServer到底可以部署几台机器？为什么要集群化部署？"><a href="#Q：NameServer到底可以部署几台机器？为什么要集群化部署？" class="headerlink" title="Q：NameServer到底可以部署几台机器？为什么要集群化部署？"></a>Q：NameServer到底可以部署几台机器？为什么要集群化部署？</h4><p>部署多台，保证高可用性。</p><p>集群化部署是为了高可用性，<code>NameServer</code> 是集群里非常关键的一个角色,如果部署一台 <code>NameServer</code>，宕机会导致 RocketMQ 集群出现故障，所以 <code>NameServer</code> 一定会多机器部署，实现一个集群，起到高可用的效果。</p><h4 id="Q：消费消息时是从Master获取还是Slave获取？"><a href="#Q：消费消息时是从Master获取还是Slave获取？" class="headerlink" title="Q：消费消息时是从Master获取还是Slave获取？"></a>Q：消费消息时是从Master获取还是Slave获取？</h4><p>可能从Master Broker获取消息，也有可能从Slave Broker获取消息</p><ul><li>消费者的系统在获取消息的时候会先发送请求到Master Broker上去，请求获取一批消息，此时Master Broker是会返回一批消息给消费者系统的</li><li>Master Broker在返回消息给消费者系统的时候，会根据当时Master Broker的 负载情况和Slave Broker的同步情况，向消费者系统建议下一次拉取消息的时候是从Master Broker拉取还是从Slave Broker拉取。</li></ul>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
            <tag> Q&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议之Raft</title>
      <link href="/2022/030923896.html"/>
      <url>/2022/030923896.html</url>
      
        <content type="html"><![CDATA[<p>最近看<code>RocketMQ</code>的时候，了解到v4.5.0之后，broker采用遵循raft协议的复制组来实现数据一致性。虎躯一震，raft协议在现在的脑子里变的熟悉又陌生…</p><p>问题不大，重新刷一遍raft。</p><p>先贴官网：<a href="https://raft.github.io/">The Raft Consensus Algorithm</a></p><p>再贴动画演示：<a href="http://thesecretlivesofdata.com/raft">Raft: Understandable Distributed Consensus</a></p><p>ps：里边的动图挺有意思😈</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ps:来自维基百科</p><blockquote><p><strong>Raft</strong>是一种用于替代<a href="https://zh.wikipedia.org/wiki/Paxos">Paxos</a>的<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E8%AD%98%E6%A9%9F%E5%88%B6">共识</a>算法。相比于<a href="https://zh.wikipedia.org/wiki/Paxos">Paxos</a>，Raft的目标是提供更清晰的逻辑分工使得算法本身能被更好地理解，同时它安全性更高，并能提供一些额外的特性。[<a href="https://zh.wikipedia.org/wiki/Raft#cite_note-raft-1">1]</a>[<a href="https://zh.wikipedia.org/wiki/Raft#cite_note-raft-paper-2">2]</a>:1Raft能为在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4">计算机集群</a>之间部署<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">有限状态机</a>提供一种通用方法，并确保集群内的任意节点在某种状态转换上保持一致。Raft算法的开源实现众多，在<a href="https://zh.wikipedia.org/wiki/Go">Go</a>、<a href="https://zh.wikipedia.org/wiki/C%2B%2B">C++</a>、<a href="https://zh.wikipedia.org/wiki/Java">Java</a>以及 <a href="https://zh.wikipedia.org/wiki/Scala">Scala</a>中都有完整的代码实现。Raft这一名字来源于”Reliable, Replicated, Redundant, And Fault-Tolerant”（“可靠、可复制、可冗余、可容错”）的首字母缩写。[<a href="https://zh.wikipedia.org/wiki/Raft#cite_note-3">3]</a></p><p>集群内的节点都对选举出的领袖采取信任，因此Raft不是一种<a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">拜占庭容错</a>算法。[<a href="https://zh.wikipedia.org/wiki/Raft#cite_note-raft-paper-2">2]</a></p></blockquote><p>Raft使用<strong>选举领袖</strong>的方式做共识算法。一个典型的Raft cluster一般有5台服务器，这可以应对两次故障。</p><p>在一个Raft cluster里，服务器有三种身份：</p><ol><li>领袖（leader）</li><li>跟随者（follower）</li><li>候选人（candidate）</li></ol><p><code>leader</code>在同一时间只会有一个，但不是一成不变的。剩下的服务器都是<code>follower</code>。</p><p><code>leader</code>会处理所有的外部请求，如果一个服务器不是<code>leader</code>，那么这个请求会被转发到<code>leader</code>处理。</p><p><code>leader</code>会在一个固定的时间段里给<code>follower</code>发送心跳（heartbeat），告诉<code>follower</code>：<em><strong>hi boys ! I am alive !</strong></em> 💋 </p><p>每个<code>follower</code>都有自己的超时窗口（每个follower的timeout可能不一样），当超过一定时间没有收到<code>leader</code>的heartbeat之后，集群就会进入选举状态。🙋</p><p>从下边三个方面来了解<code>raft</code></p><ul><li>领袖选举（Leader Election）</li><li>记录复写（Log Replication）</li><li>安全性（Safety）</li></ul><h2 id="领袖选举（leader-election）"><a href="#领袖选举（leader-election）" class="headerlink" title="领袖选举（leader election）"></a>领袖选举（leader election）</h2><img src="https://s3.bmp.ovh/imgs/2022/03/4f18033de732207c.png" alt="image-20220309153949284" style="zoom:80%;" /><p>上图可以看出，所有的节点期初都是follower角色，如果在一段时间内没有收到leader的心跳（times out），那么便切换到candidate角色，然后发起选举（starts election）；如果收到大多数的投票，那么切换成leader角色；</p><p>有两个<code>超时时间</code>（timeout）会影响leader election:</p><h3 id="election-timeout"><a href="#election-timeout" class="headerlink" title="election timeout"></a><strong>election timeout</strong></h3><p>follower等待成为candidate的时间，这个时间在150ms~300ms的范围内是随机的。</p><p>如果超过了这个timeout时间还没有收到leader的心跳，那么这个follower会做下边两件事：</p><ol><li>切换成candidate的角色</li><li>它的Term : 0-&gt;1 and  Vote Count : 0 -&gt;1 </li></ol><p>然后，它会向其它所有节点（nodes）发送一个<em>投票请求</em>（<code>Request Vote</code>）。如果接受这个请求的节点在此任期（Term）内还没有投过票，那么就会投这个Request Vote的发起方，<u>并且将自己的election timeout重置</u>。</p><img src="https://s3.bmp.ovh/imgs/2022/03/dd72e822d6c9dfc3.png" alt="image-20220309161641140" style="zoom: 50%;" /><p>当一个candidate节点有大多数的投票的时候，那么和这个节点切换为<code>leader</code>节点。</p><h3 id="heartbeat-timeout"><a href="#heartbeat-timeout" class="headerlink" title="heartbeat timeout"></a>heartbeat timeout</h3><p>leader节点开始发送<code>Append Entries</code>信息到所有的follower节点，这些信息按照<strong>heartbeat timeout</strong>指定的时间间隔去发送。followers收到Append Entries请求后<u>会重置自己的election timeout并且做出响应</u>。</p><img src="https://s3.bmp.ovh/imgs/2022/03/ebe0ba4e35560cd4.png" alt="image-20220309164255003" style="zoom:50%;" /><p>至此，这个任期（Term）将会一直存在，直到某一个follower收不到leader的心跳并且切换成了candidate角色。</p><h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><ol><li>在一个偶数的raft cluster中一旦leader不可用，剩下的几个candidate在同一时间可能有“脑裂”（split vote）的风险。当然这种case发生的概率还是极低的，只有在leader不可用时，剩下的candidate中有两个节点的剩余election time完全一致时才会发生。所以官方建议一个raft cluster最少要有五个节点。</li><li>为了避免<code>split vote</code>，raft引入了<code>randomized election timeouts</code>避免平票的case发生。</li><li>raft是一个<code>leader-based</code>共识算法，节点的数据尽量是奇数个，这样可以尽量保证<code>majority</code>的出现。</li></ol><h2 id="记录复写（log-replication）"><a href="#记录复写（log-replication）" class="headerlink" title="记录复写（log replication）"></a>记录复写（log replication）</h2><p>当集群中的leader被选举出来之后，客户端的所有请求都会发送到leader，leader来调度这些请求的顺序，并且要保证leader与followers状态的一致性。</p><h3 id="Replicated-state-machines"><a href="#Replicated-state-machines" class="headerlink" title="Replicated state machines"></a>Replicated state machines</h3><p>共识算法一般是基于复制状态机（Replicated state machines）实现的。</p><p>ps：<em>不展开了，有时间再专门写一篇</em>🏃‍♀️🏃‍♂️</p><p>raft中，<code>leader</code>将客户端请求(command)封装成一个个<code>log entry</code>，然后将这些<code>log entries</code>复制（replicate）到所有的<code>follower</code>节点，然后所有节点按照顺序应用<code>log entry</code>中的<code>command</code>，那么大家最终的状态就是一致的了。</p><img src="https://s3.bmp.ovh/imgs/2022/03/fb6457b7c11d6578.png" alt="image-20220309215626133" style="zoom: 80%;" /><h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h3><ol><li>client发了一个请求给到leader，leader将“变化”（change）添加（appended）到自己的log中。</li><li>leader在下一次heartbeat时，将“变化”（change）发送到所有的followers</li><li>一旦大多数follower承认了这个条目（entry），那么这个条目就会被提交（committed）<ol><li>类似2PC，区别是leader不需要全部节点的回复，这样只要超过一半节点处于工作状态则系统就是可用的</li></ol></li><li>leader将请求response发送到client</li></ol><h3 id="NOTE-1"><a href="#NOTE-1" class="headerlink" title="NOTE"></a>NOTE</h3><ul><li>Raft可以在网络分区（network partitions）时保持一致</li><li>raft算法为了保证高可用，并不是强一致的，而是最终一致的</li></ul><h2 id="安全性（safety）"><a href="#安全性（safety）" class="headerlink" title="安全性（safety）"></a>安全性（safety）</h2><p>没时间了，下次再说…🏃‍♂️</p>]]></content>
      
      
      <categories>
          
          <category> 分布式一致性协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> raft </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 一致性协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git-rebase入门教程</title>
      <link href="/2022/030854417.html"/>
      <url>/2022/030854417.html</url>
      
        <content type="html"><![CDATA[<img src="https://www.runoob.com/wp-content/uploads/2015/02/git-command.jpg" style="zoom: 150%;" /><h2 id="rebase基础介绍"><a href="#rebase基础介绍" class="headerlink" title="rebase基础介绍"></a>rebase基础介绍</h2><p>git代码合并有两种，git merge 和 git rebase 。两者目的相同，都是把不同分支的提交合并到一起，但是过程有差异。</p><p><strong>git merge</strong></p><p>作用：把源分支的提交合并到目标分支。过程中，目标分支改变，源分支不变。</p><p>优点：简单易上手/保留了提交历史和时间次序/分支结构不变</p><p>缺点：提交历史被大量的merge操作污染/<a href="http://www.ruanyifeng.com/blog/2018/12/git-bisect.html">git bisect</a>调试困难</p><p><strong>git rebase</strong></p><p>作用：清除了历史，将一个分支完全转移到了目标分支</p><p>优点：复杂的历史变成优雅的提交线</p><p>缺点：分支上下文模糊了/dev分支以及feature分支需要经常更新release分支变动到本地</p><img src="/2022/030854417/rebse-merge.png" class="" title="图片引用方法一"><h2 id="使用rebase时，正确的git-flow是怎样的"><a href="#使用rebase时，正确的git-flow是怎样的" class="headerlink" title="使用rebase时，正确的git flow是怎样的"></a>使用rebase时，正确的git flow是怎样的</h2><ul><li>每个feature分支都有单独的分支负责人，分支负责人需要在feature分支开发过程中每天rebase  release分支，同时告诉feature分支的自开发分支，及时跟进更新。</li><li>feature子分支开发人员需要在开发完自己的任务之后，将自己分支的点合并成一个点，然后合并到feature分支。</li><li>feature分支负责人在确定所有子分支都已开发完毕并且都压点后合并到feature分支后，交付测试验收。</li><li>测试验收通过后将feature到release分支等待上线。</li></ul><h3 id="1-feature负责人拉出功能分支，并告知功能开发人员相关分支已拉出，可以创建自己的开发分支。"><a href="#1-feature负责人拉出功能分支，并告知功能开发人员相关分支已拉出，可以创建自己的开发分支。" class="headerlink" title="1.feature负责人拉出功能分支，并告知功能开发人员相关分支已拉出，可以创建自己的开发分支。"></a>1.<strong>feature负责人拉出功能分支，并告知功能开发人员相关分支已拉出，可以创建自己的开发分支。</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git checkout -b feature-xxx</span><br><span class="hljs-meta">$ </span><span class="language-bash">git push --set-upstream origin feature-xxx</span><br></code></pre></td></tr></table></figure><h3 id="2-feature开发人员拉出属于自己的业务开发分支"><a href="#2-feature开发人员拉出属于自己的业务开发分支" class="headerlink" title="2.feature开发人员拉出属于自己的业务开发分支"></a>2.<strong>feature开发人员拉出属于自己的业务开发分支</strong></h3><p>张三</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git checkout -b feature-xxx-zhangsan</span><br><span class="hljs-meta">$ </span><span class="language-bash">git push --set-upstream origin feature-xxx-zhangsan</span><br></code></pre></td></tr></table></figure><p>李四</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git checkout -b feature-xxx-lisi</span><br><span class="hljs-meta">$ </span><span class="language-bash">git push --set-upstream origin feature-xxx-lisi</span><br></code></pre></td></tr></table></figure><h3 id="3-feature开发人员开始做业务开发"><a href="#3-feature开发人员开始做业务开发" class="headerlink" title="3.feature开发人员开始做业务开发"></a>3.<strong>feature开发人员开始做业务开发</strong></h3><p>张三</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&#x27;张三提交1&#x27;</span></span><br><span class="hljs-meta">$ </span><span class="language-bash">git push</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&#x27;张三提交2&#x27;</span></span><br><span class="hljs-meta">$ </span><span class="language-bash">git push</span><br></code></pre></td></tr></table></figure><p>李四</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&#x27;李四提交1&#x27;</span></span><br><span class="hljs-meta">$ </span><span class="language-bash">git push</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&#x27;李四提交2&#x27;</span></span><br><span class="hljs-meta">$ </span><span class="language-bash">git push</span><br></code></pre></td></tr></table></figure><img src="/2022/030854417/image-20210808225537689.png" class="" title="图片引用方法一"><h3 id="4-fearure开发人员完成自己的开发任务之后将自己的提交记录合并成一个点"><a href="#4-fearure开发人员完成自己的开发任务之后将自己的提交记录合并成一个点" class="headerlink" title="4.fearure开发人员完成自己的开发任务之后将自己的提交记录合并成一个点"></a>4.fearure开发人员完成自己的开发任务之后将自己的提交记录合并成一个点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git rebase -i 292141c  5b43fa0</span><br>-------------------------<br>pick 6e48844 张三提交1<br>pick 5f8e351 张三提交2     //进入编辑模式将第二行开始的pick全部修改成s，然后esc :wq保存，进入commit msg界面做整理<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">Rebase 356a5c0..5f8e351 onto 356a5c0 (2 commands)</span><br><span class="hljs-meta">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Commands:</span></span><br><span class="hljs-meta"># </span><span class="language-bash">p, pick &lt;commit&gt; = use commit</span><br><span class="hljs-meta"># </span><span class="language-bash">r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="hljs-meta"># </span><span class="language-bash">e, edit &lt;commit&gt; = use commit, but stop <span class="hljs-keyword">for</span> amending</span><br><span class="hljs-meta"># </span><span class="language-bash">s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="hljs-meta"># </span><span class="language-bash">f, fixup &lt;commit&gt; = like <span class="hljs-string">&quot;squash&quot;</span>, but discard this commit<span class="hljs-string">&#x27;s log message</span></span><br><span class="hljs-meta"># </span><span class="language-bash"><span class="hljs-string">x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="hljs-meta"># </span><span class="language-bash"><span class="hljs-string">b, break = stop here (continue rebase later with &#x27;</span>git rebase --<span class="hljs-built_in">continue</span><span class="hljs-string">&#x27;)</span></span><br><span class="hljs-meta"># </span><span class="language-bash"><span class="hljs-string">d, drop &lt;commit&gt; = remove commit</span></span><br><span class="hljs-meta"># </span><span class="language-bash"><span class="hljs-string">l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="hljs-meta"># </span><span class="language-bash"><span class="hljs-string">t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="hljs-meta"># </span><span class="language-bash"><span class="hljs-string">m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="hljs-meta"># </span><span class="language-bash"><span class="hljs-string">.       create a merge commit using the original merge commit&#x27;</span>s</span><br><span class="hljs-meta"># </span><span class="language-bash">.       message (or the oneline, <span class="hljs-keyword">if</span> no original merge commit was</span><br><span class="hljs-meta"># </span><span class="language-bash">.       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br><span class="hljs-meta">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="hljs-meta">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="hljs-meta">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="hljs-meta">#</span><span class="language-bash"></span><br><span class="language-bash"></span><br><br></code></pre></td></tr></table></figure><img src="/2022/030854417/git-rebase.gif" class="" title="图片引用方法一"><img src="/2022/030854417/image-20210808233344850.png" class="" title="图片引用方法一"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git status</span><br>On branch feature-xxx-zhangsan<br>Your branch and &#x27;origin/feature-xxx-zhangsan&#x27; have diverged,<br>and have 1 and 2 different commits each, respectively.<br>  (use &quot;git pull&quot; to merge the remote branch into yours)<br><br>nothing to commit, working tree clean<br><br></code></pre></td></tr></table></figure><p>idea git 中可以看到feature-xxx-zhangsan的本地分支已经将两次提交合并成<strong>一个点</strong></p><blockquote><p>have 1 and 2 different commits each, respectively.</p></blockquote><p>此时需要将本地分支<strong>强推</strong>到远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git push -f</span> <br></code></pre></td></tr></table></figure><img src="/2022/030854417/image-20210808233945968.png" class="" title="图片引用方法一"><h3 id="5-合并到feature分支"><a href="#5-合并到feature分支" class="headerlink" title="5.合并到feature分支"></a>5.合并到feature分支</h3><p>先保证本地的feature分支是最新的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git checkout feature-xxx</span><br><span class="hljs-meta">$ </span><span class="language-bash">git pull</span><br><span class="hljs-meta">$ </span><span class="language-bash">git status</span><br></code></pre></td></tr></table></figure><p>合并分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git rebase feature-xxx-zhangsan feature-xxx</span><br>Successfully rebased and updated refs/heads/feature-xxx.<br><br>注意此时的本地分支已经切换到feature-xxx，也就是rebase命令的第二个参数<br>gir rebase branchA branchB其实会做两件事情<br>1.git checkout branchB<br>2.git rebase branchA<br><span class="hljs-meta">$ </span><span class="language-bash">git branch</span><br>* feature-xxx<br>  feature-xxx-lisi<br>  feature-xxx-zhangsan<br>  main<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git status</span><br>On branch feature-xxx<br>Your branch is ahead of &#x27;origin/feature-xxx&#x27; by 1 commit.<br>  (use &quot;git push&quot; to publish your local commits)<br><br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure><p>git status可以看到feature-xxx分支上已经有了feature-xxx-zhangsan分支合并的点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git push</span><br></code></pre></td></tr></table></figure><h3 id="6-合并到功能分支的时候出现冲突怎么办"><a href="#6-合并到功能分支的时候出现冲突怎么办" class="headerlink" title="6.合并到功能分支的时候出现冲突怎么办"></a>6.合并到功能分支的时候出现冲突怎么办</h3><p>李四同样走了这个流程但是在合并到feature分支的时候遇到了麻烦，有代码冲突了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git rebase feature-xxx-lisi feature-xxx</span><br>Successfully rebased and updated refs/heads/feature-xxx.<br><span class="hljs-meta"></span><br><span class="hljs-meta">$ </span><span class="language-bash">git status</span><br>On branch feature-xxx<br>Your branch and &#x27;origin/feature-xxx&#x27; have diverged,<br>and have 1 and 1 different commits each, respectively.<br>  (use &quot;git pull&quot; to merge the remote branch into yours)<br><br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure><p>git status看到功能分支feature-xxx有落后，这时候需要拉取落后的代码到本地</p><p>注意这里不要直接使用git pull ，git pull 其实会做两个事情 git fetch + git merge , 会产生git提交记录的环线，这是我们要避免产生的事情。</p><p><strong>请使用git pull –rebase</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git pull --rebase</span><br>error: could not apply 49f99fb... lisi commit all<br>Resolve all conflicts manually, mark them as resolved with<br>&quot;git add/rm &lt;conflicted_files&gt;&quot;, then run &quot;git rebase --continue&quot;.<br>You can instead skip this commit: run &quot;git rebase --skip&quot;.<br>To abort and get back to the state before &quot;git rebase&quot;, run &quot;git rebase --abort&quot;.<br>Could not apply 49f99fb... lisi commit all<br>Auto-merging src/main/java/com/example/leetcode/editor/test/Test.java<br>CONFLICT (content): Merge conflict in src/main/java/com/example/leetcode/editor/test/Test.java<br></code></pre></td></tr></table></figure><p>可以看到出现了冲突（CONFLICT），这时候需要到idea中处理冲突</p><img src="/2022/030854417/git-rebase-lisi-fix2.gif" class="" title="图片引用方法一"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git status</span><br>On branch feature-xxx<br>Your branch is ahead of &#x27;origin/feature-xxx&#x27; by 1 commit.<br>  (use &quot;git push&quot; to publish your local commits)<br><br>nothing to commit, working tree clean<br><span class="hljs-meta"></span><br><span class="hljs-meta">$ </span><span class="language-bash">git push</span><br></code></pre></td></tr></table></figure><h2 id="rebase常见问题"><a href="#rebase常见问题" class="headerlink" title="rebase常见问题"></a>rebase常见问题</h2><h3 id="1-作为一个feature负责人，发现落后release分支太多了怎么办"><a href="#1-作为一个feature负责人，发现落后release分支太多了怎么办" class="headerlink" title="1.作为一个feature负责人，发现落后release分支太多了怎么办"></a>1.作为一个feature负责人，发现落后release分支太多了怎么办</h3><p>出现这种情况有两种原因：</p><ul><li>feature分支太久没有关注release分支的状态，导致落后release分支太多</li><li>release分支被人无脑提交，没有压点</li></ul><p>第二种情况是要<strong>极力避免</strong>的，这种不负责任的提交很可能导致各个feature分支后续的rebase提交需要解决多次冲突</p><p>第一种情况怎么解决：</p><ul><li>先尝试直接rebase release，如果没有冲突或者只需要解决一两次冲突，那么就采用直接rebase的方式。</li><li>如果rebase release方式有冲突的点很多，那么可以采用将feature分支压点然后切换到release分支使用cherry-pick的方式做代码合并，然后重新创建feature分支，或者set-up-stream重新指向远程feature分支。</li></ul><h3 id="2-有人把开发主干分支压点然后强推了怎么办"><a href="#2-有人把开发主干分支压点然后强推了怎么办" class="headerlink" title="2.有人把开发主干分支压点然后强推了怎么办"></a>2.有人把开发主干分支压点然后强推了怎么办</h3><p><em><strong>注意：使用rebase的方式，如果分支是个公共分支，那么不允许rebase，这会打乱别人本地仓库的git提交线</strong></em></p><h2 id="commit-msg规范"><a href="#commit-msg规范" class="headerlink" title="commit msg规范"></a>commit msg规范</h2><ul><li>feat：新功能（feature）</li><li>fix：bug修复</li><li>refactor：重构</li><li>test：补充单元测试</li><li>docs：补充文档</li><li>style：样式/格式，不影响业务代码 or 逻辑</li></ul><p>提交描述的时候，如果涉及多个内容，则使用1.2.3做标注</p><ol><li>做了什么</li><li>做了什么</li><li>做了什么</li></ol><h2 id="一定要注意的事情"><a href="#一定要注意的事情" class="headerlink" title="一定要注意的事情"></a>一定要注意的事情</h2><ul><li>做任何操作的<strong>前后</strong>都<strong>一定</strong>要 git  status查看工作区状态</li><li>自己的分支可以git push -f ，但是<strong>公共分支，一定不要这么做！</strong></li><li>不要对公共分支做压点操作，<strong>永远不要！</strong></li><li>使用git pull –rebase <strong>一定</strong>是正确的。尽量不要使用git pull，一有冲突就会merge</li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
