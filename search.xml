<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode常用技巧/算法汇总</title>
      <link href="/2022/031820106.html"/>
      <url>/2022/031820106.html</url>
      
        <content type="html"><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><blockquote><p><strong>贪心算法</strong>（英语：greedy algorithm），又称<strong>贪婪算法</strong>，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95">算法</a>。[<a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95#cite_note-paike-1">1]</a>比如在<a href="https://zh.wikipedia.org/wiki/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98">旅行推销员问题</a>中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。</p><p>贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。</p><p>贪心算法与<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a>的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p><p>贪心法可以解决一些<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BC%98%E5%8C%96">最优化</a>问题，如：求<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE">图</a>中的<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">最小生成树</a>、求<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">哈夫曼编码</a>……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。在不同情况，选择最优的解，可能会导致辛普森悖论（Simpson’s Paradox），不一定出现最优的解。</p><p>贪心算法在数据科学领域被广泛应用，特别是金融工程。其中一个贪心算法例子就是Ensemble method。</p></blockquote><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><table><thead><tr><th align="center">题目</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></td><td align="center">中等</td></tr></tbody></table><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h4 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h4><blockquote><p>滑动窗口指的是这样一类问题的求解方法，在数组上通过双指针同向移动而解决的一类问题。其实这样的问题我们可以不必为它们专门命名一个名字，它们的解法其实是很自然的。</p><p>使用滑动窗口解决的问题通常是暴力解法的优化，掌握这一类问题最好的办法就是练习，然后思考清楚为什么可以使用滑动窗口。</p></blockquote><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><a href="https://leetcode-cn.com/tag/sliding-window/problemset/">leetcode题库</a></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>问答:RocketMQ</title>
      <link href="/2022/031526519.html"/>
      <url>/2022/031526519.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于RocketMQ v4.5.0之前的版本</p></blockquote><h4 id="Q：RocketMQ由哪些角色组成，每个角色作用和特点是什么？"><a href="#Q：RocketMQ由哪些角色组成，每个角色作用和特点是什么？" class="headerlink" title="Q：RocketMQ由哪些角色组成，每个角色作用和特点是什么？"></a>Q：RocketMQ由哪些角色组成，每个角色作用和特点是什么？</h4><table><thead><tr><th align="center">角色</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">NameServer</td><td align="center">无状态，动态列表；这也是和zookeeper的重要区别之一。zookeeper是有状态的。</td></tr><tr><td align="center">Producer</td><td align="center">消息生产者，负责发消息到Broker。</td></tr><tr><td align="center">Broker</td><td align="center">就是MQ本身，负责收发消息、持久化消息等。</td></tr><tr><td align="center">Consumer</td><td align="center">消息消费者，负责从Broker上拉取消息进行消费，消费完进行ack。</td></tr></tbody></table><h4 id="Q：RocketMQ-Broker中的消息被消费后会立即删除吗？"><a href="#Q：RocketMQ-Broker中的消息被消费后会立即删除吗？" class="headerlink" title="Q：RocketMQ Broker中的消息被消费后会立即删除吗？"></a>Q：RocketMQ Broker中的消息被消费后会立即删除吗？</h4><p>不会，每条消息都会持久化到<code>CommitLog</code>中，每个<code>Consumer</code>连接到<code>Broker</code>后会维持消费进度信息，当有消息消费后只是当前<code>Consumer</code>的消费进度（CommitLog的offset）更新了。</p><p>4.6版本默认48小时后会删除不再使用的CommitLog文件</p><ul><li>检查这个文件最后访问时间</li><li>判断是否大于过期时间</li><li>指定时间删除，默认凌晨4点</li></ul><h4 id="Q：RocketMQ消息是push还是pull？"><a href="#Q：RocketMQ消息是push还是pull？" class="headerlink" title="Q：RocketMQ消息是push还是pull？"></a>Q：RocketMQ消息是push还是pull？</h4><ul><li>RocketMQ没有真正意义的push，都是pull，虽然有push类，但实际底层实现采用的是<strong>长轮询机制</strong>，即拉取方式。</li><li>broker端属性 longPollingEnable 标记是否开启长轮询。默认开启</li></ul><h4 id="Q：为什么要主动拉取消息而不使用事件监听方式？"><a href="#Q：为什么要主动拉取消息而不使用事件监听方式？" class="headerlink" title="Q：为什么要主动拉取消息而不使用事件监听方式？"></a>Q：为什么要主动拉取消息而不使用事件监听方式？</h4><p>事件驱动方式是建立好长连接，由事件（发送数据）的方式来实时推送。</p><p>如果<code>broker</code>主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成<u>消息在 <code>Consumer</code> 端堆积过多，同时又不能被其他 <code>Consumer</code> 消费</u>的情况。而 pull 的方式可以根据当前自身情况来 pull，不会造成过多的压力而造成瓶颈。所以采取了 pull 的方式。</p><h4 id="Q：路由注册机制"><a href="#Q：路由注册机制" class="headerlink" title="Q：路由注册机制"></a>Q：路由注册机制</h4><img src="https://cdn.jsdelivr.net/gh/HMYDK/picb@main/img/image-20220314165017030.png" alt="image-20220314165017030" style="zoom: 50%;" /><ul><li>集群中所有的<code>Broker</code>每隔30s向所有的<code>NameServer</code>发送心跳包，<u>注册Topic路由信息</u>。</li><li><code>NameServer</code>在收到Broker端的心跳包时首先会<u>更新路由表，并记录收到心跳包的时间</u>。</li><li><code>NameServer</code>会启动一个定时任务每10s会扫描<code>Broker</code>，如果<code>NameServer</code>连续120s未收到<code>Broker</code>的心跳包，会判定<code>Broker</code>已下线，将从路由表中将此<code>Broker</code>剔除。</li><li>如果 <code>Nameserver</code> 与 <code>Broker</code> 端的长连接断开，<code>NameServer</code> 会立即感知 <code>Broker</code> 下线并从路由表中将该 <code>Broker</code> 移除。</li><li>消息客户端(消息发送者、消息消费者)在任意时刻<u>只会和其中一台</u> <code>NameServer</code> 建立 连接，并每隔 30s 向 <code>NameServer</code> 查询路由信息，如果查询到结果会<u>更新发送者的 本地路由信息</u>。</li></ul><h4 id="Q：broker主从服务器都在运行过程中，消息消费是从主节点拉取还是从节点拉取？"><a href="#Q：broker主从服务器都在运行过程中，消息消费是从主节点拉取还是从节点拉取？" class="headerlink" title="Q：broker主从服务器都在运行过程中，消息消费是从主节点拉取还是从节点拉取？"></a>Q：broker主从服务器都在运行过程中，消息消费是从主节点拉取还是从节点拉取？</h4><p>A：默认情况下，RocketMQ 消息消费者从<code>master</code>服务器拉取，当<code>master</code>服务器积压的消息超 过了物理内存的 40%，则建议从<code>slave</code>服务器拉取。但如果 slaveReadEnable 为 false，表示<code>slave</code>服务器不可读，<code>slave</code>服务器也不会接管消息拉取。</p><h4 id="Q：当消息消费者向slave服务器拉取消息后，会一直从slave服务器拉取？"><a href="#Q：当消息消费者向slave服务器拉取消息后，会一直从slave服务器拉取？" class="headerlink" title="Q：当消息消费者向slave服务器拉取消息后，会一直从slave服务器拉取？"></a>Q：当消息消费者向slave服务器拉取消息后，会一直从slave服务器拉取？</h4><p>A：不是的，分如下情况：</p><ol><li>如果<code>slave</code>服务器的 slaveReadEnable 设置为 false，则下次拉取，从<code>masrer</code>服务器拉取。 </li><li>如果<code>slave</code>服务器允许读取并且<code>slave</code>服务器积压的消息未超过其物理内存的 40%，下次拉取使用的 Broker 为订阅组的 brokerId 指定的 Broker 服务器，该值默认为 0，代表<code>master</code>服务器。</li><li>如果<code>slave</code>服务器允许读取并且<code>slave</code>服务器积压的消息超过了其物理内存的 40%，下次拉取使用的 Broker 为订阅组的 whichBrokerWhenConsumeSlowly 指定的 Broker 服 务器，该值默认为 1，代表<code>master</code>服务器。</li></ol><h4 id="Q：broker主从节点的消费进度是如何同步的？"><a href="#Q：broker主从节点的消费进度是如何同步的？" class="headerlink" title="Q：broker主从节点的消费进度是如何同步的？"></a>Q：broker主从节点的消费进度是如何同步的？</h4><p>A：</p><ul><li>消息消费进度的同步是单向的，<code>slave</code>服务器开启一个定时任务，定时从<code>master</code>服务器同步 消息消费进度；</li><li>无论消息消费者是从<code>master</code>服务器拉的消息还是从<code>slave</code>服务器拉取的消息，在向 Broker 反馈消息消费进度时，优先向<code>master</code>服务器汇报；</li><li>消息消费者向<code>master</code>服务器拉取消息时， 如果消息消费者内存中存在消息消费进度时，<code>masrer</code>会尝试更新消息消费进度。</li></ul><h4 id="Q：消息发送是如何实现高可用的？"><a href="#Q：消息发送是如何实现高可用的？" class="headerlink" title="Q：消息发送是如何实现高可用的？"></a>Q：消息发送是如何实现高可用的？</h4><blockquote><p>如果 Broker 端收到内存抖动等因素造成单条写入数据发生抖动，单个Broker 端积压的请求太大还得不到及时处理，会极大的造成客户端消息发送的延长时间，设想一下，如果由于 Broker 压力增大，写入一条消息需要 500ms 甚至超过1s，并且队列中积压了5000 条消息，消息发送端的默认超时时间为 3s，如果按照这样的速度，这些请求在轮到Broker 执行写入请求时，客户端已经将这个请求超时了，这样不仅会造成大量的无效处理，还会导致客户端发送超时。</p></blockquote><p>Broker端快速失败原理如下：</p><img src="https://cdn.jsdelivr.net/gh/HMYDK/picb@main/img/image-20220315141506789.png" alt="image-20220315141506789" style="zoom:80%;" /><ul><li>消息发送者向 Broker 发送消息写入请求，Broker 端在接收到请求后会首先放入一个队列中(SendThreadPoolQueue)，默认容量为 <u>10000</u>。</li><li>Broker 会专门使用一个线程池(SendMessageExecutor)去从队列中获取任务并执行消息写入请求，为了保证消息的顺序处理，该线程池默认线程个数为<u>1</u>。</li><li>开启一个定时调度线程，每隔 10 毫秒去检查队列中的第一个排队节点，如果该节点的排队时间已经超过了200 ms，就会取消该队列中所有已超过 200ms 的请求，立即向客户端返回失败，这样<u>客户端能尽快进行重试</u>，因为 Broker 都是集群部署，下次重试可以发送到其他Broker 上，这样能最大程度保证消息发送在默认 3s 的时间内经过重试机制，能有效避免某一台Broker 由于瞬时压力大而造成的消息发送不可用，从而实现消息发送的高可用。</li><li>业务上我们在发送消息时，应该做好异常捕获，将失败消息入库，借助定时任务做重试。</li></ul><h4 id="Q：RocketMQ路由寻找流程"><a href="#Q：RocketMQ路由寻找流程" class="headerlink" title="Q：RocketMQ路由寻找流程"></a>Q：RocketMQ路由寻找流程</h4><img src="https://cdn.jsdelivr.net/gh/HMYDK/picb@main/img/image-20220315161613014.png" alt="image-20220315161613014" style="zoom:80%;" /><ul><li>如果 <code>Broker</code> 开启了自动创建 Topic，在启动的时候会默认创建主题：<code>TBW102</code>，并会随着 <code>Broker</code> 发送到 <code>Nameserver</code> 的心跳包汇报给 <code>Nameserver</code>，继而从<code>Nameserver</code> 查询路由信息时能返回路由信息。 </li><li>消息发送者在消息发送时首先会查本地缓存，如果本地缓存中存在，直接返回路由信息。</li><li>如果缓存不存在，则向 <code>Nameserver</code> 查询路由信息，如果 <code>Nameserver</code> 存在该路由信息，就直接返回。 </li><li>如果 <code>Nameserver</code> 不存在该 topic 的路由信息，如果没有开启自动创建主题，则抛出No route info of this topic。 </li><li>如果开启了自动创建主题，则使用默认主题向 <code>Nameserver</code> 查询路由信息，并使用默认 Topic 的路由信息为自己的路由信息，将不会抛出 No route info of this topic。</li></ul><h4 id="Q：RocketMQ如何做负载均衡的？"><a href="#Q：RocketMQ如何做负载均衡的？" class="headerlink" title="Q：RocketMQ如何做负载均衡的？"></a>Q：RocketMQ如何做负载均衡的？</h4><p><u>通过Topic在多Broker中分布式存储实现</u>。</p><p><strong>producer端</strong></p><p>发送端指定 <code>message queue</code>发送消息到相应的 broker，来达到写入时的负载均衡</p><ul><li>提升写入吞吐量，当多个<code>producer</code>同时向一个 <code>broker</code> 写入数据的时候，性能会下降</li><li>消息分布在多 <code>broker</code> 中，为负载消费做准备</li></ul><p>默认策略是<code>随机选择</code>：</p><ul><li>producer 维护一个 index</li><li>每次取节点会自增</li><li>index 向所有 broker 个数取余</li><li>自带容错策略</li></ul><p><strong>consumer端</strong></p><p>采用的是平均分配算法来进行负载均衡。</p><p><strong>其他负载均衡算法</strong></p><ul><li>平均分配策略(<strong>默认</strong>)(AllocateMessageQueueAveragely)</li><li>环形分配策略(AllocateMessageQueueAveragelyByCircle)</li><li>手动配置分配策略(AllocateMessageQueueByConfig)</li><li>机房分配策略(AllocateMessageQueueByMachineRoom)</li><li>一致性哈希分配策略(AllocateMessageQueueConsistentHash)</li><li>靠近机房策略(AllocateMachineRoomNearby)</li></ul><h4 id="Q：当消费负载均衡consumer和queue不对等的时候会发生什么？"><a href="#Q：当消费负载均衡consumer和queue不对等的时候会发生什么？" class="headerlink" title="Q：当消费负载均衡consumer和queue不对等的时候会发生什么？"></a>Q：当消费负载均衡consumer和queue不对等的时候会发生什么？</h4><p>Consumer 和 queue 会优先平均分配。</p><ul><li>如果 Consumer 少于 queue 的个数，则会存在部分 Consumer 消费多个 queue 的情况</li><li>如果 Consumer 等于 queue 的个数，那就是一个 Consumer 消费一个 queue</li><li>如果 Consumer 个数大于 queue 的个数，那么会有部分 Consumer 空余出来，白白的浪费了</li></ul><h4 id="Q：消息重复消费如何解决？"><a href="#Q：消息重复消费如何解决？" class="headerlink" title="Q：消息重复消费如何解决？"></a>Q：消息重复消费如何解决？</h4><p>影响消息正常发送和消费的<strong>重要原因是网络的不确定性。</strong></p><p><strong>引起重复消费的原因</strong></p><ul><li><p><strong>ACK</strong><br>正常情况下在<code>consumer</code>真正消费完消息后应该发送<code>ack</code>，通知<code>broker</code>该消息已正常消费，从<code>queue</code>中剔除</p><p>当<code>ack</code>因为网络原因无法发送到<code>broker</code>，<code>broker</code>会认为词条消息没有被消费，此后会开启消息重投机制把消息再次投递到<code>consumer</code></p></li><li><p><strong>消费模式</strong><br>在<code>CLUSTERING</code>模式下，消息在<code>broker</code>中会保证相同<code>group</code>的<code>consumer</code>消费一次，但是针对不同<code>group</code>的<code>consumer</code>会推送多次</p></li></ul><p><strong>解决方案</strong></p><ul><li><p>数据库表：处理消息前，使用消息主键在表中带有约束的字段中insert</p></li><li><p>Map：单机时可以使用map ConcurrentHashMap -&gt; putIfAbsent guava cache</p></li><li><p>Redis：分布式锁搞起来。</p></li></ul><h4 id="Q：RocketMQ如何保证消息不丢失？"><a href="#Q：RocketMQ如何保证消息不丢失？" class="headerlink" title="Q：RocketMQ如何保证消息不丢失？"></a>Q：RocketMQ如何保证消息不丢失？</h4><p>首先在如下三个部分都可能会出现丢失消息的情况：Producer端，Broker端，Consumer端</p><h5 id="Producer端保证消息不丢失"><a href="#Producer端保证消息不丢失" class="headerlink" title="Producer端保证消息不丢失"></a>Producer端保证消息不丢失</h5><ul><li><p>采取send()同步发消息，发送结果是同步感知的。</p></li><li><p>发送失败后可以重试，设置重试次数。默认3次。</p><p><code>producer.setRetryTimesWhenSendFailed(10);</code></p></li><li><p>集群部署，比如发送失败了的原因可能是当前Broker宕机了，重试的时候会发送到其他Broker上。</p></li></ul><h5 id="Broker端保证消息不丢失"><a href="#Broker端保证消息不丢失" class="headerlink" title="Broker端保证消息不丢失"></a>Broker端保证消息不丢失</h5><ul><li><p>修改刷盘策略为同步刷盘。默认情况下是异步刷盘的。</p><p><code>flushDiskType = SYNC_FLUSH</code></p></li><li><p>集群部署，主从模式，高可用。</p></li></ul><p><strong>Consumer端保证消息不丢失</strong></p><ul><li>完全正常消费之后进行手动ack确认</li></ul><h4 id="Q：RocketMQ的消息堆积如何处理？"><a href="#Q：RocketMQ的消息堆积如何处理？" class="headerlink" title="Q：RocketMQ的消息堆积如何处理？"></a>Q：RocketMQ的消息堆积如何处理？</h4><p>首先要找到是什么原因导致的消息堆积，是<code>Producer</code>太多了还是<code>Consumer</code>太少了或者其他情况，总之先定位一个大概的问题。</p><p>再看下消息的消费速度是否正常，正常的话，那就上线更多的<code>Consumer</code>临时解决消息堆积的问题。</p><h4 id="Q：堆积消息会超时删除么？"><a href="#Q：堆积消息会超时删除么？" class="headerlink" title="Q：堆积消息会超时删除么？"></a>Q：堆积消息会超时删除么？</h4><p>不会，RocketMQ中的消息只会在commitLog被删除的时候才会消失。也就是说未消费的消息不会存在超时删除这种情况。</p><h4 id="Q：堆积的消息会不会进死信队列？"><a href="#Q：堆积的消息会不会进死信队列？" class="headerlink" title="Q：堆积的消息会不会进死信队列？"></a>Q：堆积的消息会不会进死信队列？</h4><p>不会，消息在消费失败之后会进入重试队列（%RETRY%+ConsumerGroup），18次才会进入死信队列（%DLQ%+ConsumerGroup）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageStoreConfig</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 每隔如下时间会进行重试，到最后一次时间重试失败的话就进入死信队列了。</span> <span class="token keyword">private</span> <span class="token class-name">String</span> messageDelayLevel <span class="token operator">=</span> <span class="token string">"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Q：RocketMQ-在分布式事务支持这块机制的底层原理"><a href="#Q：RocketMQ-在分布式事务支持这块机制的底层原理" class="headerlink" title="Q：RocketMQ 在分布式事务支持这块机制的底层原理?"></a>Q：RocketMQ 在分布式事务支持这块机制的底层原理?</h4><p>分布式系统中的事务可以使用<code>TCC</code>（Try、Confirm、Cancel）、<code>2pc</code>来解决分布式系统中的消息原子性</p><p>RocketMQ 4.3+ 提供分布事务功能，通过 RocketMQ 事务消息能达到分布式事务的最终一致</p><p><strong>RocketMQ实现方式：</strong></p><ul><li><strong>Half Message</strong>：<br>预处理消息，当<code>broker</code>收到此类消息后，会存储到<code>RMQ_SYS_TRANS_HALF_TOPIC</code>的消息消费队列中</li><li><strong>检查事务状态</strong>：<br><code>Broker</code>会开启一个定时任务，消费<code>RMQ_SYS_TRANS_HALF_TOPIC</code>队列中的消息，每次执行任务会向消息发送者确认事务执行状态（提交、回滚、未知），如果是未知，<code>Broker</code>会定时去回调在重新检查。</li><li><strong>超时</strong>：<br>如果超过回查次数，默认回滚消息。</li></ul><p><u>也就是事务消息并未真正进入Topic的queue，而是用了临时queue来放所谓的half message，等提交事务后才会真正的将half message转移到topic下的queue。</u></p><h4 id="Q：高吞吐量下如何优化生产者和消费者的性能"><a href="#Q：高吞吐量下如何优化生产者和消费者的性能" class="headerlink" title="Q：高吞吐量下如何优化生产者和消费者的性能?"></a>Q：高吞吐量下如何优化生产者和消费者的性能?</h4><ul><li>开发<ul><li>同一group下，多机部署，并行消费</li><li>单个Consumer提高消费线程个数</li><li>批量消费<ul><li>消息批量拉取</li><li>业务逻辑批量处理</li></ul></li></ul></li><li>运维<ul><li>网卡调优</li><li>jvm调优</li><li>多线程与cpu调优</li><li>Page Cache</li></ul></li></ul><h4 id="Q：任何一台Broker突然宕机了怎么办？"><a href="#Q：任何一台Broker突然宕机了怎么办？" class="headerlink" title="Q：任何一台Broker突然宕机了怎么办？"></a>Q：任何一台Broker突然宕机了怎么办？</h4><p><code>Broker</code>主从架构以及多副本策略。<code>Master</code> 收到消息后会同步给 <code>Slave</code>，这样一条消息就不止一份了，<code>Master</code> 宕机了还有 <code>slave</code> 中的消息可用，保证了MQ的可靠性和高可用性。而且 Rocket MQ4.5.0 开始就支持了 <code>Dlegder</code> 模式，基于 <code>raft</code>的，做到了真正意义的 <code>HA</code>(highly available)。</p><h4 id="Q：Master-Broker-突然挂了，这样会怎么样？"><a href="#Q：Master-Broker-突然挂了，这样会怎么样？" class="headerlink" title="Q：Master Broker 突然挂了，这样会怎么样？"></a>Q：Master Broker 突然挂了，这样会怎么样？</h4><p><strong>RocketMQ 4.5 版本之前</strong>，用 Slave Broker 同步数据，尽量保证数据不丢失，但是一旦 Master 故障了，Slave 是没法自动切换成 Master 的。<br>所以在这种情况下，如果 Master Broker 宕机了，这时就得手动做一些运维操作，把 Slave Broker 重新修改一些配置，重启机器给调整为Master Broker，这是有点麻烦的，而且会导致中间一段时间不可用。</p><p><strong>RocketMQ 4.5之后</strong>支持了一种叫做 Dledger 机制，基于 Raft 协议实现的一个机制。<br>我们可以让一个 Master Broker 对应多个 Slave Broker， 一旦 Master Broker 宕机了，在多个 Slave 中通过 Dledger 技术 将一个 Slave Broker 选为新的 Master Broker 对外提供服务。<br>在生产环境中可以是用 Dledger 机制实现自动故障切换，只要10秒或者几十秒的时间就可以完成</p><h4 id="Q：Broker把自己的信息注册到哪个NameServer上？"><a href="#Q：Broker把自己的信息注册到哪个NameServer上？" class="headerlink" title="Q：Broker把自己的信息注册到哪个NameServer上？"></a>Q：Broker把自己的信息注册到哪个NameServer上？</h4><p>每个<code>Broker</code>向所有的<code>NameServer</code>上注册自己的信息，即每个<code>NameServer</code>上有所有的<code>Broker</code>信息</p><h4 id="Q：NameServer到底可以部署几台机器？为什么要集群化部署？"><a href="#Q：NameServer到底可以部署几台机器？为什么要集群化部署？" class="headerlink" title="Q：NameServer到底可以部署几台机器？为什么要集群化部署？"></a>Q：NameServer到底可以部署几台机器？为什么要集群化部署？</h4><p>部署多台，保证高可用性。</p><p>集群化部署是为了高可用性，<code>NameServer</code> 是集群里非常关键的一个角色,如果部署一台 <code>NameServer</code>，宕机会导致 RocketMQ 集群出现故障，所以 <code>NameServer</code> 一定会多机器部署，实现一个集群，起到高可用的效果。</p><h4 id="Q：消费消息时是从Master获取还是Slave获取？"><a href="#Q：消费消息时是从Master获取还是Slave获取？" class="headerlink" title="Q：消费消息时是从Master获取还是Slave获取？"></a>Q：消费消息时是从Master获取还是Slave获取？</h4><p>可能从Master Broker获取消息，也有可能从Slave Broker获取消息</p><ul><li>消费者的系统在获取消息的时候会先发送请求到Master Broker上去，请求获取一批消息，此时Master Broker是会返回一批消息给消费者系统的</li><li>Master Broker在返回消息给消费者系统的时候，会根据当时Master Broker的 负载情况和Slave Broker的同步情况，向消费者系统建议下一次拉取消息的时候是从Master Broker拉取还是从Slave Broker拉取。</li></ul>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
            <tag> Q&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议之Raft</title>
      <link href="/2022/030923896.html"/>
      <url>/2022/030923896.html</url>
      
        <content type="html"><![CDATA[<p>最近看<code>RocketMQ</code>的时候，了解到v4.5.0之后，broker采用遵循raft协议的复制组来实现数据一致性。虎躯一震，raft协议在现在的脑子里变的熟悉又陌生…</p><p>问题不大，重新刷一遍raft。</p><p>先贴官网：<a href="https://raft.github.io/">The Raft Consensus Algorithm</a></p><p>再贴动画演示：<a href="http://thesecretlivesofdata.com/raft">Raft: Understandable Distributed Consensus</a></p><p>ps：里边的动图挺有意思😈</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ps:来自维基百科</p><blockquote><p><strong>Raft</strong>是一种用于替代<a href="https://zh.wikipedia.org/wiki/Paxos">Paxos</a>的<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E8%AD%98%E6%A9%9F%E5%88%B6">共识</a>算法。相比于<a href="https://zh.wikipedia.org/wiki/Paxos">Paxos</a>，Raft的目标是提供更清晰的逻辑分工使得算法本身能被更好地理解，同时它安全性更高，并能提供一些额外的特性。[<a href="https://zh.wikipedia.org/wiki/Raft#cite_note-raft-1">1]</a>[<a href="https://zh.wikipedia.org/wiki/Raft#cite_note-raft-paper-2">2]</a>:1Raft能为在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4">计算机集群</a>之间部署<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">有限状态机</a>提供一种通用方法，并确保集群内的任意节点在某种状态转换上保持一致。Raft算法的开源实现众多，在<a href="https://zh.wikipedia.org/wiki/Go">Go</a>、<a href="https://zh.wikipedia.org/wiki/C%2B%2B">C++</a>、<a href="https://zh.wikipedia.org/wiki/Java">Java</a>以及 <a href="https://zh.wikipedia.org/wiki/Scala">Scala</a>中都有完整的代码实现。Raft这一名字来源于”Reliable, Replicated, Redundant, And Fault-Tolerant”（“可靠、可复制、可冗余、可容错”）的首字母缩写。[<a href="https://zh.wikipedia.org/wiki/Raft#cite_note-3">3]</a></p><p>集群内的节点都对选举出的领袖采取信任，因此Raft不是一种<a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">拜占庭容错</a>算法。[<a href="https://zh.wikipedia.org/wiki/Raft#cite_note-raft-paper-2">2]</a></p></blockquote><p>Raft使用<strong>选举领袖</strong>的方式做共识算法。一个典型的Raft cluster一般有5台服务器，这可以应对两次故障。</p><p>在一个Raft cluster里，服务器有三种身份：</p><ol><li>领袖（leader）</li><li>跟随者（follower）</li><li>候选人（candidate）</li></ol><p><code>leader</code>在同一时间只会有一个，但不是一成不变的。剩下的服务器都是<code>follower</code>。</p><p><code>leader</code>会处理所有的外部请求，如果一个服务器不是<code>leader</code>，那么这个请求会被转发到<code>leader</code>处理。</p><p><code>leader</code>会在一个固定的时间段里给<code>follower</code>发送心跳（heartbeat），告诉<code>follower</code>：<em><strong>hi boys ! I am alive !</strong></em> 💋 </p><p>每个<code>follower</code>都有自己的超时窗口（每个follower的timeout可能不一样），当超过一定时间没有收到<code>leader</code>的heartbeat之后，集群就会进入选举状态。🙋</p><p>从下边三个方面来了解<code>raft</code></p><ul><li>领袖选举（Leader Election）</li><li>记录复写（Log Replication）</li><li>安全性（Safety）</li></ul><h2 id="领袖选举（leader-election）"><a href="#领袖选举（leader-election）" class="headerlink" title="领袖选举（leader election）"></a>领袖选举（leader election）</h2><img src="https://s3.bmp.ovh/imgs/2022/03/4f18033de732207c.png" alt="image-20220309153949284" style="zoom:80%;" /><p>上图可以看出，所有的节点期初都是follower角色，如果在一段时间内没有收到leader的心跳（times out），那么便切换到candidate角色，然后发起选举（starts election）；如果收到大多数的投票，那么切换成leader角色；</p><p>有两个<code>超时时间</code>（timeout）会影响leader election:</p><h3 id="election-timeout"><a href="#election-timeout" class="headerlink" title="election timeout"></a><strong>election timeout</strong></h3><p>follower等待成为candidate的时间，这个时间在150ms~300ms的范围内是随机的。</p><p>如果超过了这个timeout时间还没有收到leader的心跳，那么这个follower会做下边两件事：</p><ol><li>切换成candidate的角色</li><li>它的Term : 0-&gt;1 and  Vote Count : 0 -&gt;1 </li></ol><p>然后，它会向其它所有节点（nodes）发送一个<em>投票请求</em>（<code>Request Vote</code>）。如果接受这个请求的节点在此任期（Term）内还没有投过票，那么就会投这个Request Vote的发起方，<u>并且将自己的election timeout重置</u>。</p><img src="https://s3.bmp.ovh/imgs/2022/03/dd72e822d6c9dfc3.png" alt="image-20220309161641140" style="zoom: 50%;" /><p>当一个candidate节点有大多数的投票的时候，那么和这个节点切换为<code>leader</code>节点。</p><h3 id="heartbeat-timeout"><a href="#heartbeat-timeout" class="headerlink" title="heartbeat timeout"></a>heartbeat timeout</h3><p>leader节点开始发送<code>Append Entries</code>信息到所有的follower节点，这些信息按照<strong>heartbeat timeout</strong>指定的时间间隔去发送。followers收到Append Entries请求后<u>会重置自己的election timeout并且做出响应</u>。</p><img src="https://s3.bmp.ovh/imgs/2022/03/ebe0ba4e35560cd4.png" alt="image-20220309164255003" style="zoom:50%;" /><p>至此，这个任期（Term）将会一直存在，直到某一个follower收不到leader的心跳并且切换成了candidate角色。</p><h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><ol><li>在一个偶数的raft cluster中一旦leader不可用，剩下的几个candidate在同一时间可能有“脑裂”（split vote）的风险。当然这种case发生的概率还是极低的，只有在leader不可用时，剩下的candidate中有两个节点的剩余election time完全一致时才会发生。所以官方建议一个raft cluster最少要有五个节点。</li><li>为了避免<code>split vote</code>，raft引入了<code>randomized election timeouts</code>避免平票的case发生。</li><li>raft是一个<code>leader-based</code>共识算法，节点的数据尽量是奇数个，这样可以尽量保证<code>majority</code>的出现。</li></ol><h2 id="记录复写（log-replication）"><a href="#记录复写（log-replication）" class="headerlink" title="记录复写（log replication）"></a>记录复写（log replication）</h2><p>当集群中的leader被选举出来之后，客户端的所有请求都会发送到leader，leader来调度这些请求的顺序，并且要保证leader与followers状态的一致性。</p><h3 id="Replicated-state-machines"><a href="#Replicated-state-machines" class="headerlink" title="Replicated state machines"></a>Replicated state machines</h3><p>共识算法一般是基于复制状态机（Replicated state machines）实现的。</p><p>ps：<em>不展开了，有时间再专门写一篇</em>🏃‍♀️🏃‍♂️</p><p>raft中，<code>leader</code>将客户端请求(command)封装成一个个<code>log entry</code>，然后将这些<code>log entries</code>复制（replicate）到所有的<code>follower</code>节点，然后所有节点按照顺序应用<code>log entry</code>中的<code>command</code>，那么大家最终的状态就是一致的了。</p><img src="https://s3.bmp.ovh/imgs/2022/03/fb6457b7c11d6578.png" alt="image-20220309215626133" style="zoom: 80%;" /><h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h3><ol><li>client发了一个请求给到leader，leader将“变化”（change）添加（appended）到自己的log中。</li><li>leader在下一次heartbeat时，将“变化”（change）发送到所有的followers</li><li>一旦大多数follower承认了这个条目（entry），那么这个条目就会被提交（committed）<ol><li>类似2PC，区别是leader不需要全部节点的回复，这样只要超过一半节点处于工作状态则系统就是可用的</li></ol></li><li>leader将请求response发送到client</li></ol><h3 id="NOTE-1"><a href="#NOTE-1" class="headerlink" title="NOTE"></a>NOTE</h3><ul><li>Raft可以在网络分区（network partitions）时保持一致</li><li>raft算法为了保证高可用，并不是强一致的，而是最终一致的</li></ul><h2 id="安全性（safety）"><a href="#安全性（safety）" class="headerlink" title="安全性（safety）"></a>安全性（safety）</h2><p>没时间了，下次再说…🏃‍♂️</p>]]></content>
      
      
      <categories>
          
          <category> 分布式一致性协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> raft </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 一致性协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git-rebase入门教程</title>
      <link href="/2022/030854417.html"/>
      <url>/2022/030854417.html</url>
      
        <content type="html"><![CDATA[<img src="https://www.runoob.com/wp-content/uploads/2015/02/git-command.jpg" style="zoom: 150%;" /><h2 id="rebase基础介绍"><a href="#rebase基础介绍" class="headerlink" title="rebase基础介绍"></a>rebase基础介绍</h2><p>git代码合并有两种，git merge 和 git rebase 。两者目的相同，都是把不同分支的提交合并到一起，但是过程有差异。</p><p><strong>git merge</strong></p><p>作用：把源分支的提交合并到目标分支。过程中，目标分支改变，源分支不变。</p><p>优点：简单易上手/保留了提交历史和时间次序/分支结构不变</p><p>缺点：提交历史被大量的merge操作污染/<a href="http://www.ruanyifeng.com/blog/2018/12/git-bisect.html">git bisect</a>调试困难</p><p><strong>git rebase</strong></p><p>作用：清除了历史，将一个分支完全转移到了目标分支</p><p>优点：复杂的历史变成优雅的提交线</p><p>缺点：分支上下文模糊了/dev分支以及feature分支需要经常更新release分支变动到本地</p><img src="/2022/030854417/rebse-merge.png" class="" title="图片引用方法一"><h2 id="使用rebase时，正确的git-flow是怎样的"><a href="#使用rebase时，正确的git-flow是怎样的" class="headerlink" title="使用rebase时，正确的git flow是怎样的"></a>使用rebase时，正确的git flow是怎样的</h2><ul><li>每个feature分支都有单独的分支负责人，分支负责人需要在feature分支开发过程中每天rebase  release分支，同时告诉feature分支的自开发分支，及时跟进更新。</li><li>feature子分支开发人员需要在开发完自己的任务之后，将自己分支的点合并成一个点，然后合并到feature分支。</li><li>feature分支负责人在确定所有子分支都已开发完毕并且都压点后合并到feature分支后，交付测试验收。</li><li>测试验收通过后将feature到release分支等待上线。</li></ul><h3 id="1-feature负责人拉出功能分支，并告知功能开发人员相关分支已拉出，可以创建自己的开发分支。"><a href="#1-feature负责人拉出功能分支，并告知功能开发人员相关分支已拉出，可以创建自己的开发分支。" class="headerlink" title="1.feature负责人拉出功能分支，并告知功能开发人员相关分支已拉出，可以创建自己的开发分支。"></a>1.<strong>feature负责人拉出功能分支，并告知功能开发人员相关分支已拉出，可以创建自己的开发分支。</strong></h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git checkout -b feature-xxx$ git push --set-upstream origin feature-xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-feature开发人员拉出属于自己的业务开发分支"><a href="#2-feature开发人员拉出属于自己的业务开发分支" class="headerlink" title="2.feature开发人员拉出属于自己的业务开发分支"></a>2.<strong>feature开发人员拉出属于自己的业务开发分支</strong></h3><p>张三</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git checkout -b feature-xxx-zhangsan$ git push --set-upstream origin feature-xxx-zhangsan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>李四</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git checkout -b feature-xxx-lisi$ git push --set-upstream origin feature-xxx-lisi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-feature开发人员开始做业务开发"><a href="#3-feature开发人员开始做业务开发" class="headerlink" title="3.feature开发人员开始做业务开发"></a>3.<strong>feature开发人员开始做业务开发</strong></h3><p>张三</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git add .$ git commit -m &#39;张三提交1&#39;$ git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git add .$ git commit -m &#39;张三提交2&#39;$ git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>李四</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git add .$ git commit -m &#39;李四提交1&#39;$ git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git add .$ git commit -m &#39;李四提交2&#39;$ git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2022/030854417/image-20210808225537689.png" class="" title="图片引用方法一"><h3 id="4-fearure开发人员完成自己的开发任务之后将自己的提交记录合并成一个点"><a href="#4-fearure开发人员完成自己的开发任务之后将自己的提交记录合并成一个点" class="headerlink" title="4.fearure开发人员完成自己的开发任务之后将自己的提交记录合并成一个点"></a>4.fearure开发人员完成自己的开发任务之后将自己的提交记录合并成一个点</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git rebase -i 292141c  5b43fa0-------------------------pick 6e48844 张三提交1pick 5f8e351 张三提交2     &#x2F;&#x2F;进入编辑模式将第二行开始的pick全部修改成s，然后esc :wq保存，进入commit msg界面做整理# Rebase 356a5c0..5f8e351 onto 356a5c0 (2 commands)## Commands:# p, pick &lt;commit&gt; &#x3D; use commit# r, reword &lt;commit&gt; &#x3D; use commit, but edit the commit message# e, edit &lt;commit&gt; &#x3D; use commit, but stop for amending# s, squash &lt;commit&gt; &#x3D; use commit, but meld into previous commit# f, fixup &lt;commit&gt; &#x3D; like &quot;squash&quot;, but discard this commit&#39;s log message# x, exec &lt;command&gt; &#x3D; run command (the rest of the line) using shell# b, break &#x3D; stop here (continue rebase later with &#39;git rebase --continue&#39;)# d, drop &lt;commit&gt; &#x3D; remove commit# l, label &lt;label&gt; &#x3D; label current HEAD with a name# t, reset &lt;label&gt; &#x3D; reset HEAD to a label# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]# .       create a merge commit using the original merge commit&#39;s# .       message (or the oneline, if no original merge commit was# .       specified). Use -c &lt;commit&gt; to reword the commit message.## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2022/030854417/git-rebase.gif" class="" title="图片引用方法一"><img src="/2022/030854417/image-20210808233344850.png" class="" title="图片引用方法一"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git statusOn branch feature-xxx-zhangsanYour branch and &#39;origin&#x2F;feature-xxx-zhangsan&#39; have diverged,and have 1 and 2 different commits each, respectively.  (use &quot;git pull&quot; to merge the remote branch into yours)nothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>idea git 中可以看到feature-xxx-zhangsan的本地分支已经将两次提交合并成<strong>一个点</strong></p><blockquote><p>have 1 and 2 different commits each, respectively.</p></blockquote><p>此时需要将本地分支<strong>强推</strong>到远程分支</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git push -f <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2022/030854417/image-20210808233945968.png" class="" title="图片引用方法一"><h3 id="5-合并到feature分支"><a href="#5-合并到feature分支" class="headerlink" title="5.合并到feature分支"></a>5.合并到feature分支</h3><p>先保证本地的feature分支是最新的</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git checkout feature-xxx$ git pull$ git status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>合并分支</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git rebase feature-xxx-zhangsan feature-xxxSuccessfully rebased and updated refs&#x2F;heads&#x2F;feature-xxx.注意此时的本地分支已经切换到feature-xxx，也就是rebase命令的第二个参数gir rebase branchA branchB其实会做两件事情1.git checkout branchB2.git rebase branchA$ git branch* feature-xxx  feature-xxx-lisi  feature-xxx-zhangsan  main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git statusOn branch feature-xxxYour branch is ahead of &#39;origin&#x2F;feature-xxx&#39; by 1 commit.  (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>git status可以看到feature-xxx分支上已经有了feature-xxx-zhangsan分支合并的点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git push<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-合并到功能分支的时候出现冲突怎么办"><a href="#6-合并到功能分支的时候出现冲突怎么办" class="headerlink" title="6.合并到功能分支的时候出现冲突怎么办"></a>6.合并到功能分支的时候出现冲突怎么办</h3><p>李四同样走了这个流程但是在合并到feature分支的时候遇到了麻烦，有代码冲突了</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git rebase feature-xxx-lisi feature-xxxSuccessfully rebased and updated refs&#x2F;heads&#x2F;feature-xxx.$ git statusOn branch feature-xxxYour branch and &#39;origin&#x2F;feature-xxx&#39; have diverged,and have 1 and 1 different commits each, respectively.  (use &quot;git pull&quot; to merge the remote branch into yours)nothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>git status看到功能分支feature-xxx有落后，这时候需要拉取落后的代码到本地</p><p>注意这里不要直接使用git pull ，git pull 其实会做两个事情 git fetch + git merge , 会产生git提交记录的环线，这是我们要避免产生的事情。</p><p><strong>请使用git pull –rebase</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git pull --rebaseerror: could not apply 49f99fb... lisi commit allResolve all conflicts manually, mark them as resolved with&quot;git add&#x2F;rm &lt;conflicted_files&gt;&quot;, then run &quot;git rebase --continue&quot;.You can instead skip this commit: run &quot;git rebase --skip&quot;.To abort and get back to the state before &quot;git rebase&quot;, run &quot;git rebase --abort&quot;.Could not apply 49f99fb... lisi commit allAuto-merging src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;leetcode&#x2F;editor&#x2F;test&#x2F;Test.javaCONFLICT (content): Merge conflict in src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;leetcode&#x2F;editor&#x2F;test&#x2F;Test.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到出现了冲突（CONFLICT），这时候需要到idea中处理冲突</p><img src="/2022/030854417/git-rebase-lisi-fix2.gif" class="" title="图片引用方法一"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git statusOn branch feature-xxxYour branch is ahead of &#39;origin&#x2F;feature-xxx&#39; by 1 commit.  (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree clean$ git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="rebase常见问题"><a href="#rebase常见问题" class="headerlink" title="rebase常见问题"></a>rebase常见问题</h2><h3 id="1-作为一个feature负责人，发现落后release分支太多了怎么办"><a href="#1-作为一个feature负责人，发现落后release分支太多了怎么办" class="headerlink" title="1.作为一个feature负责人，发现落后release分支太多了怎么办"></a>1.作为一个feature负责人，发现落后release分支太多了怎么办</h3><p>出现这种情况有两种原因：</p><ul><li>feature分支太久没有关注release分支的状态，导致落后release分支太多</li><li>release分支被人无脑提交，没有压点</li></ul><p>第二种情况是要<strong>极力避免</strong>的，这种不负责任的提交很可能导致各个feature分支后续的rebase提交需要解决多次冲突</p><p>第一种情况怎么解决：</p><ul><li>先尝试直接rebase release，如果没有冲突或者只需要解决一两次冲突，那么就采用直接rebase的方式。</li><li>如果rebase release方式有冲突的点很多，那么可以采用将feature分支压点然后切换到release分支使用cherry-pick的方式做代码合并，然后重新创建feature分支，或者set-up-stream重新指向远程feature分支。</li></ul><h3 id="2-有人把开发主干分支压点然后强推了怎么办"><a href="#2-有人把开发主干分支压点然后强推了怎么办" class="headerlink" title="2.有人把开发主干分支压点然后强推了怎么办"></a>2.有人把开发主干分支压点然后强推了怎么办</h3><p><em><strong>注意：使用rebase的方式，如果分支是个公共分支，那么不允许rebase，这会打乱别人本地仓库的git提交线</strong></em></p><h2 id="commit-msg规范"><a href="#commit-msg规范" class="headerlink" title="commit msg规范"></a>commit msg规范</h2><ul><li>feat：新功能（feature）</li><li>fix：bug修复</li><li>refactor：重构</li><li>test：补充单元测试</li><li>docs：补充文档</li><li>style：样式/格式，不影响业务代码 or 逻辑</li></ul><p>提交描述的时候，如果涉及多个内容，则使用1.2.3做标注</p><ol><li>做了什么</li><li>做了什么</li><li>做了什么</li></ol><h2 id="一定要注意的事情"><a href="#一定要注意的事情" class="headerlink" title="一定要注意的事情"></a>一定要注意的事情</h2><ul><li>做任何操作的<strong>前后</strong>都<strong>一定</strong>要 git  status查看工作区状态</li><li>自己的分支可以git push -f ，但是<strong>公共分支，一定不要这么做！</strong></li><li>不要对公共分支做压点操作，<strong>永远不要！</strong></li><li>使用git pull –rebase <strong>一定</strong>是正确的。尽量不要使用git pull，一有冲突就会merge</li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
